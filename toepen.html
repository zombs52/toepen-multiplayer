<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toepen - Dutch Card Game</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .players-section {
            display: grid;
            gap: 20px;
            margin-bottom: 30px;
            min-height: 200px;
        }
        
        /* Dynamic layouts based on player count */
        .players-section.players-2 {
            grid-template-columns: 1fr 1fr;
            grid-template-areas: "opponent1 center";
        }
        
        .players-section.players-3 {
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-areas: "opponent1 center opponent2";
        }
        
        .players-section.players-4 {
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-areas: 
                "opponent1 opponent2 opponent3"
                "center center center";
        }
        
        .activity-log {
            position: fixed;
            right: 20px;
            top: 20px;
            width: 300px;
            max-height: 400px;
            background: rgba(0,0,0,0.8);
            border-radius: 10px;
            padding: 15px;
            z-index: 1000;
            display: none;
        }
        
        .activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
        }
        
        .activity-messages {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        
        .activity-message {
            margin-bottom: 5px;
            padding: 5px;
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .activity-message.game-event {
            color: #81c784;
        }
        
        .activity-message.player-event {
            color: #64b5f6;
        }
        
        .activity-toggle {
            position: fixed;
            right: 20px;
            top: 20px;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 1001;
            font-size: 1.2rem;
        }
        
        .game-menu {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }
        
        .menu-button {
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-bottom: 10px;
            display: block;
            min-width: 120px;
        }
        
        .menu-button:hover {
            background: rgba(0,0,0,0.9);
        }

        .player {
            background: rgba(255,255,255,0.15);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .player.active {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .player.current-player {
            background: rgba(255,215,0,0.2);
        }

        .player.eliminated {
            background: rgba(255,0,0,0.3);
            opacity: 0.7;
        }

        .player.eliminated::after {
            content: "ELIMINATED";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,0,0,0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player-points {
            font-size: 1rem;
            margin-bottom: 15px;
        }

        .player-tricks {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 80px;
        }

        .card {
            width: 50px;
            height: 70px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #333;
            font-size: 0.8rem;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .card.playable {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76,175,80,0.5);
        }

        .card.red {
            color: #d32f2f;
        }

        .card.black {
            color: #333;
        }

        .card-back {
            background: linear-gradient(45deg, #1565c0, #0d47a1);
            color: white;
        }

        .playing-area {
            text-align: center;
            margin: 30px 0;
        }

        .trick-area {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            min-height: 100px;
            align-items: center;
        }

        .played-card {
            width: 80px;
            height: 110px;
            background: white;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 2px solid #333;
            position: relative;
            font-size: 1.2rem;
            color: #333;
        }

        .played-card.red {
            color: #d32f2f;
        }

        .played-card.black {
            color: #333;
        }

        .played-card.winning {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255,215,0,0.8);
        }

        .played-card::after {
            content: attr(data-player);
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: white;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #da190b;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #ff9800;
            color: white;
        }

        .btn-warning:hover {
            background: #e68900;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .game-status {
            text-align: center;
            font-size: 1.2rem;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .setup-screen {
            text-align: center;
            padding: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            margin-top: 50px;
        }

        .setup-screen h2 {
            margin-bottom: 30px;
            font-size: 2rem;
        }

        .setup-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .input-group input {
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            text-align: center;
        }

        .stakes-indicator {
            background: #ff6b35;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            display: inline-block;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .players-section {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .controls {
                flex-wrap: wrap;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }

        @keyframes flash {
            0%, 100% { background-color: transparent; }
            50% { background-color: rgba(255, 107, 107, 0.3); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>üÉè TOEPEN V-1.6 üÉè</h1>
            <p>The Classic Dutch Card Game</p>
        </div>

        <div id="lobbyScreen" class="setup-screen" style="display: none;">
            <h2>Game Lobby</h2>
            <div class="setup-controls">
                <div class="input-group">
                    <label>Lobby Code:</label>
                    <input type="text" id="lobbyCode" placeholder="Enter lobby code or leave empty to create" style="width: 200px;">
                </div>
                <div class="input-group">
                    <label>Your Name:</label>
                    <input type="text" id="lobbyPlayerName" placeholder="Enter your name" value="Player">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-primary" onclick="createLobby()">Create Lobby</button>
                    <button class="btn btn-primary" onclick="joinLobby()">Join Lobby</button>
                    <button class="btn btn-danger" onclick="backToSetup()">Back</button>
                </div>
            </div>
            
            <div id="lobbyPlayers" style="margin-top: 30px; display: none;">
                <h3>Players in Lobby:</h3>
                <div id="playersList" style="margin: 20px 0;"></div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="addBot()" id="addBotBtn">Add Bot</button>
                    <button class="btn btn-primary" onclick="startLobbyGame()" id="startGameBtn" style="display: none;">Start Game</button>
                    <button class="btn btn-danger" onclick="leaveLobby()">Leave Lobby</button>
                </div>
                <p id="waitingMessage" style="display: none; margin-top: 15px; font-style: italic; color: #666;">Waiting for host to start the game...</p>
                <p style="margin-top: 15px; font-size: 0.9rem;">Share this code with friends: <strong id="currentLobbyCode"></strong> <button class="btn btn-secondary" onclick="copyLobbyCode()" style="margin-left: 10px; padding: 2px 8px; font-size: 0.8rem;">Copy</button></p>
            </div>
        </div>
        <div id="setupScreen" class="setup-screen">
            <h2>Setup Game</h2>
            <div class="setup-controls">
                <div class="input-group">
                    <label>Your Name:</label>
                    <input type="text" id="playerName" placeholder="Enter your name" value="Player">
                </div>
                <div class="input-group">
                    <label>Number of Players (2-4):</label>
                    <input type="number" id="numPlayers" min="2" max="4" value="3">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-primary" onclick="startGame()">Play with Bots</button>
                    <button class="btn btn-warning" onclick="showLobby()">Play with Friends</button>
                </div>
            </div>
            
            <div style="margin-top: 40px; text-align: left; max-width: 600px; margin-left: auto; margin-right: auto;">
                <h3>Hoe speel je Toepen:</h3>
                <p><strong>Doel:</strong> Zorg niet dat je de 10 punten haalt!</p>
                <p><strong>Kaarten:</strong> Piketkaarten. elke speler krijgt 4 kaarten. Je speelt 4 slagen per ronde.</p>
                <p><strong>Waardes:</strong> J (laagste), Q, K, A, 7, 8, 9, 10 (Hoogste)</p>
                <p><strong>Score:</strong> Winnaar krijgt 0 punten, losers krijgen strafpunten ter hoogte van de inzet!</p>
                <p><strong>Toepen:</strong> In jouw beurt kan je toepen om de inzet te verhogen.</p>
                <p><strong>Inzet:</strong> Start met 1, verhoogt met 1 voor elke toep. Fold is de inzet waar je voor speelde voor de toep.</p>
                <p><strong>Winnaar:</strong> Bij 10 punten verlies je. Laatste speler die overblijft wint!</p>
                <p><strong>STV:</strong> Het spel voldoet nog niet aan de stv regels, nog WIP: blind toepen, -1 met boertoep, altijd kunnen toepen</p>
            </div>
        </div>

        <!-- Toep Decision Overlay -->
        <div id="toepDecisionOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.4); z-index: 1000;">
            <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #1a1a2e, #16213e); border: 2px solid #ffeb3b; border-radius: 15px; padding: 20px; max-width: 450px; width: 90%; text-align: center; box-shadow: 0 5px 20px rgba(255, 235, 59, 0.3);">
                <h2 style="color: #ffeb3b; margin-bottom: 15px; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">üÉè TOEP! üÉè</h2>
                <div id="toepMessage" style="margin: 15px 0; font-size: 1.1rem; color: white; font-weight: 500;"></div>
                <div style="background: rgba(255, 235, 59, 0.15); border: 1px solid #ffeb3b; border-radius: 8px; padding: 12px; margin: 15px 0;">
                    <div style="color: #ffeb3b; font-weight: bold; font-size: 1.1rem;">New Stakes: <span id="newStakes">2</span> points</div>
                </div>
                <div style="margin: 15px 0; font-size: 0.9rem; color: #ddd; line-height: 1.4;">
                    <p style="margin: 5px 0;">You entered at <strong style="color: #ffeb3b;"><span id="yourEntryStakes">1</span> points</strong></p>
                    <p style="margin: 5px 0;">Fold now: <strong style="color: #ff6b6b;"><span id="foldPenalty">1</span> penalty points</strong></p>
                    <p style="margin: 5px 0;">Continue and lose: <strong style="color: #ff6b6b;"><span id="continuePenalty">2</span> penalty points</strong></p>
                </div>
                <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="acceptToep()" style="box-shadow: 0 3px 10px rgba(76, 175, 80, 0.3);">Accept & Continue</button>
                    <button class="btn btn-danger" onclick="foldToToep()" style="box-shadow: 0 3px 10px rgba(244, 67, 54, 0.3);">Fold Round</button>
                </div>
            </div>
        </div>

        <div id="gameScreen" style="display: none;">
            <div class="game-info">
                <div>Round: <span id="roundNumber">1</span></div>
                <div>Current Stakes: <span id="roundValue">1</span></div>
                <div>Tricks: <span id="tricksPlayed">0</span>/4</div>
            </div>

            <div class="players-section" id="playersSection">
                <!-- Dynamic player layout will be generated here -->
            </div>

            <div id="player0" class="player current-player">
                <div class="player-name">You</div>
                <div class="player-points">Points: 0</div>
                <div class="player-tricks">This round: 0 tricks</div>
                <div class="player-cards" id="yourCards"></div>
            </div>

            <div class="controls">
                <button class="btn btn-warning" id="toepBtn" onclick="toep()">Toep! (Raise Stakes)</button>
                <button class="btn btn-danger" id="foldBtn" onclick="fold()">Fold</button>
                <button class="btn btn-secondary" id="vuileWasBtn" onclick="submitVuileWas()" style="display: none;">Vuile Was</button>
                <button class="btn btn-secondary" id="witteWasBtn" onclick="submitWitteWas()" style="display: none;">Witte Was</button>
                <button class="btn btn-primary" id="blindToepBtn" onclick="callBlindToep()" style="display: none;">Blind Toep Next Round!</button>
            </div>
        </div>
    </div>

    <!-- Game Menu -->
    <div class="game-menu" id="gameMenu" style="display: none;">
        <button class="menu-button" onclick="returnToMainMenu()">üè† Main Menu</button>
        <button class="menu-button" onclick="toggleActivityLog()">üìã Activity Log</button>
    </div>

    <!-- Activity Log Toggle Button -->
    <button class="activity-toggle" onclick="toggleActivityLog()" title="Show/Hide Activity Log">üìã</button>

    <!-- Activity Log Panel -->
    <div class="activity-log" id="activityLog">
        <div class="activity-header">
            <h3 style="margin: 0; font-size: 1.1rem;">Game Activity</h3>
            <button onclick="toggleActivityLog()" style="background: none; border: none; color: white; cursor: pointer;">‚úñ</button>
        </div>
        <div class="activity-messages" id="activityMessages">
            <!-- Messages will be added here dynamically -->
        </div>
    </div>

    <script>
        class ToepenGame {
            constructor() {
                this.players = [];
                this.currentPlayer = 0;
                this.round = 1;
                this.stakes = 1;
                this.deck = [];
                this.currentTrick = [];
                this.tricksPlayed = 0;
                this.gamePhase = 'setup'; // setup, laundry, playing, roundEnd, gameEnd
                this.playersInRound = [];
                this.tricksTaken = [];
                this.leadSuit = null;
                this.roundTrickWins = [];
                this.isHost = false;
                this.lobbyCode = '';
                this.lobbyPlayers = [];
                // NEW: Track the stakes each player entered the round at
                this.playerStakesOnEntry = [];
                // Laundry system
                this.laundryPhaseComplete = false;
                this.firstCardPlayed = false;
                this.pendingLaundry = null; // {playerIndex, type, cards}
                this.awaitingInspection = false;
                this.laundryPhaseTimer = null;
                // Toep restriction - track who toep'd last to prevent consecutive toeps
                this.lastToeper = -1; // -1 means no one has toep'd yet this round
                // Blind toep tracking
                this.blindToepCaller = -1; // -1 means no blind toep called
                this.pendingBlindToepResponse = false; // Flag to track if blind toep needs processing
                this.isBlindToepDecision = false; // Flag to distinguish blind toep vs regular toep decision
                // Processing state to prevent rapid clicks
                this.isProcessing = false;
            }

            createDeck() {
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                const ranks = [
                    {symbol: 'J', value: 1},    // Jack is lowest
                    {symbol: 'Q', value: 2},
                    {symbol: 'K', value: 3},
                    {symbol: 'A', value: 4},
                    {symbol: '7', value: 5},
                    {symbol: '8', value: 6},
                    {symbol: '9', value: 7},
                    {symbol: '10', value: 8}    // 10 is highest
                ];

                this.deck = [];
                suits.forEach(suit => {
                    ranks.forEach(rank => {
                        this.deck.push({
                            suit: suit,
                            rank: rank.symbol,
                            value: rank.value,
                            color: (suit === '‚ô•' || suit === '‚ô¶') ? 'red' : 'black'
                        });
                    });
                });
            }

            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            dealCards() {
                this.players.forEach(player => {
                    player.hand = [];
                    for (let i = 0; i < 4; i++) {
                        player.hand.push(this.deck.pop());
                    }
                });
            }

            // Laundry detection methods
            isVuileWas(hand) {
                // Dirty laundry: 3 face cards (J, Q, K) and one 7
                const faceCards = hand.filter(card => ['J', 'Q', 'K'].includes(card.rank));
                const sevens = hand.filter(card => card.rank === '7');
                return faceCards.length === 3 && sevens.length === 1;
            }

            isWitteWas(hand) {
                // White laundry: 4 face cards (J, Q, K)
                const faceCards = hand.filter(card => ['J', 'Q', 'K'].includes(card.rank));
                return faceCards.length === 4;
            }

            hasLaundry(hand) {
                return this.isVuileWas(hand) || this.isWitteWas(hand);
            }

            getLaundryType(hand) {
                if (this.isWitteWas(hand)) return 'witte';
                if (this.isVuileWas(hand)) return 'vuile';
                return null;
            }

            startRound() {
                // Remove eliminated players
                this.players = this.players.filter(p => p.points < 10);
                
                if (this.players.length <= 1) {
                    this.endGame();
                    return;
                }

                this.createDeck();
                this.shuffleDeck();
                this.dealCards();
                
                // Reset any face-up card penalties from previous rounds
                this.players.forEach(player => {
                    player.cardsVisible = false;
                });
                this.currentTrick = [];
                this.tricksPlayed = 0;
                this.stakes = 1;
                this.playersInRound = [...Array(this.players.length).keys()];
                this.roundTrickWins = new Array(this.players.length).fill(0);
                this.gamePhase = 'laundry'; // Start with laundry phase
                this.currentPlayer = 0;
                this.leadSuit = null;
                this.laundryPhaseComplete = false;
                this.firstCardPlayed = false;
                this.isProcessing = false; // Reset processing flag for new round
                
                // NEW: Initialize stakes tracking - all players start at stakes=1
                this.playerStakesOnEntry = new Array(this.players.length).fill(1);
                
                // Reset toep restriction for new round
                this.lastToeper = -1;
                
                // If blind toep was called, adjust starting stakes
                if (this.blindToepCaller >= 0) {
                    this.stakes = 3;
                    // All players start at stakes 3 for penalty calculation
                    this.playerStakesOnEntry = new Array(this.players.length).fill(3);
                    this.updateGameStatus(`${this.players[this.blindToepCaller].name} called Blind Toep! Stakes start at 3. Others must accept or fold.`);
                    // Mark blind toeper as last toeper (can't toep again until someone else toeps)
                    this.lastToeper = this.blindToepCaller;
                    // Set flag to trigger fold/continue decisions after cards are shown
                    this.pendingBlindToepResponse = true;
                    this.blindToepCaller = -1; // Reset after using
                }
                
                this.updateDisplay();
                this.updateGameStatus(`Round ${this.round} begins! Check for laundry before playing.`);
                
                // Start laundry phase
                this.handleLaundryPhase();
            }

            handleLaundryPhase() {
                this.updateGameStatus("Laundry phase - You can claim Vuile Was (3 face cards + 1 seven) or Witte Was (4 face cards). Bluffing is allowed! Others can inspect your claim. You have 15 seconds.");
                
                // Handle AI players' laundry decisions after a delay
                setTimeout(() => this.processAILaundryDecisions(), 3000);
                
                // Set the main laundry phase timer
                this.setLaundryPhaseTimer();
            }

            setLaundryPhaseTimer() {
                // Clear existing timer if any
                if (this.laundryPhaseTimer) {
                    clearTimeout(this.laundryPhaseTimer);
                }
                
                // Set new timer - auto-end laundry phase after 15 seconds if no activity
                this.laundryPhaseTimer = setTimeout(() => {
                    if (this.gamePhase === 'laundry' && !this.awaitingInspection) {
                        this.endLaundryPhase();
                    }
                }, 15000);
            }

            processAILaundryDecisions() {
                for (let i = 1; i < this.players.length; i++) {
                    if (this.deck.length >= 4) {
                        // Check if AI has actual laundry
                        if (this.hasLaundry(this.players[i].hand)) {
                            // AI always submits laundry if they have it
                            const laundryType = this.getLaundryType(this.players[i].hand);
                            this.submitLaundry(i, laundryType);
                            return; // Process one at a time
                        } else {
                            // AI might occasionally bluff (5% chance)
                            if (Math.random() < 0.05) {
                                const bluffType = Math.random() < 0.7 ? 'vuile' : 'witte'; // More likely to claim vuile was
                                this.submitLaundry(i, bluffType);
                                return; // Process one at a time
                            }
                        }
                    }
                }
                
                // If no AI submitted laundry, continue checking or end phase
                if (!this.awaitingInspection) {
                    // Give a bit more time for human player decisions
                    setTimeout(() => {
                        if (this.gamePhase === 'laundry' && !this.awaitingInspection) {
                            this.endLaundryPhase();
                        }
                    }, 2000);
                }
            }

            submitLaundry(playerIndex, type) {
                if (this.deck.length < 4) {
                    this.updateGameStatus("Not enough cards left in deck for laundry.");
                    return false;
                }

                const player = this.players[playerIndex];
                const laundryCards = [...player.hand];
                
                this.pendingLaundry = {
                    playerIndex: playerIndex,
                    type: type,
                    cards: laundryCards
                };

                this.awaitingInspection = true;
                
                // Reset the laundry phase timer since someone made a claim
                this.setLaundryPhaseTimer();
                
                const typeText = type === 'witte' ? 'Witte was' : 'Vuile was';
                this.updateGameStatus(`${player.name} claims ${typeText}! Click on them to inspect (risky - you get penalty if they're telling the truth). Auto-proceeds in 10 seconds.`);
                
                // Auto-proceed after 10 seconds if no inspection
                setTimeout(() => {
                    if (this.awaitingInspection && this.pendingLaundry) {
                        this.processLaundry(false);
                    }
                }, 10000);

                this.updateDisplay();
                return true;
            }

            inspectLaundry(inspectorIndex) {
                if (!this.awaitingInspection || !this.pendingLaundry) return;
                
                const inspector = this.players[inspectorIndex];
                this.updateGameStatus(`${inspector.name} inspects the laundry...`);
                
                setTimeout(() => this.processLaundry(true, inspectorIndex), 1500);
            }

            processLaundry(wasInspected, inspectorIndex = -1) {
                if (!this.pendingLaundry) return;

                const { playerIndex, type, cards } = this.pendingLaundry;
                const player = this.players[playerIndex];

                if (!wasInspected) {
                    // No one inspected - player gets away with it (even if bluffing)
                    this.updateGameStatus(`No one inspects ${player.name}'s ${type === 'witte' ? 'Witte was' : 'Vuile was'} claim. ${player.name} gets new cards.`);
                    
                    // Give player new hand regardless of whether they actually had laundry
                    player.hand = [];
                    for (let i = 0; i < 4; i++) {
                        if (this.deck.length > 0) {
                            player.hand.push(this.deck.pop());
                        }
                    }
                } else {
                    // Someone inspected - now we validate the actual cards
                    const isValidLaundry = type === 'witte' ? this.isWitteWas(cards) : this.isVuileWas(cards);
                    
                    if (isValidLaundry) {
                        // Valid laundry - inspector gets penalty
                        this.players[inspectorIndex].points += 1;
                        this.updateGameStatus(`${this.players[inspectorIndex].name} inspects and finds valid ${type === 'witte' ? 'Witte was' : 'Vuile was'}! Inspector gets 1 penalty point.`);
                        
                        // Give player new hand
                        player.hand = [];
                        for (let i = 0; i < 4; i++) {
                            if (this.deck.length > 0) {
                                player.hand.push(this.deck.pop());
                            }
                        }
                        
                        // Show visual inspection result
                        this.showLaundryInspectionResult(playerIndex, cards, true);
                    } else {
                        // Invalid laundry - bluff caught!
                        player.points += 1;
                        player.cardsVisible = true; // Play with cards face up
                        
                        this.updateGameStatus(`${this.players[inspectorIndex].name} catches ${player.name} bluffing! Gets 1 penalty point and visible cards.`);
                        
                        // Show visual inspection result
                        this.showLaundryInspectionResult(playerIndex, cards, false);
                    }
                }

                this.pendingLaundry = null;
                this.awaitingInspection = false;
                this.updateDisplay();

                // Continue with laundry phase or move to playing
                setTimeout(() => {
                    if (this.deck.length >= 4) {
                        this.processAILaundryDecisions();
                    } else {
                        this.endLaundryPhase();
                    }
                }, 2000);
            }

            endLaundryPhase() {
                // Clear any remaining laundry phase timer
                if (this.laundryPhaseTimer) {
                    clearTimeout(this.laundryPhaseTimer);
                    this.laundryPhaseTimer = null;
                }
                
                this.gamePhase = 'playing';
                this.laundryPhaseComplete = true;
                
                // Check if there's a pending blind toep response
                if (this.pendingBlindToepResponse) {
                    this.updateGameStatus(`Processing blind toep responses...`);
                    setTimeout(() => this.handleBlindToepResponse(), 1000);
                    return;
                }
                
                this.updateDisplay();
                this.updateGameStatus(`Round ${this.round} - ${this.players[this.currentPlayer].name}'s turn.`);
                
                if (this.currentPlayer !== 0) {
                    setTimeout(() => this.handleAIPlay(), 1500);
                }
            }

            toep() {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== 0) return;
                
                // Check if this player can toep (can't toep twice in a row)
                if (this.lastToeper === 0) {
                    this.updateGameStatus("You can't toep twice in a row! Wait for someone else to toep first.");
                    return;
                }
                
                this.stakes += 1;
                this.lastToeper = 0; // Mark human player as the last one to toep
                this.updateGameStatus(`You toep! Stakes raised to ${this.stakes}. Others must accept or fold.`);
                
                // DON'T update stakes tracking yet - only update for players who accept
                
                // Check if other players accept or fold
                setTimeout(() => this.handleToepResponse(), 1000);
                this.updateDisplay();
            }

            handleToepResponse() {
                let playersToRespond = this.playersInRound.filter(p => p !== 0);
                let playersFolded = [];
                let playersAccepted = [];
                
                playersToRespond.forEach(playerIndex => {
                    // AI decision: 40% chance to fold when stakes are high
                    const foldChance = this.stakes >= 4 ? 0.4 : 0.2;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    } else {
                        playersAccepted.push(playerIndex);
                        // Update stakes tracking for AI players who accept
                        this.playerStakesOnEntry[playerIndex] = this.stakes;
                    }
                });
                
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = this.playerStakesOnEntry[p];
                        this.players[p].points += penaltyPoints;
                        foldMessages.push(`${this.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    this.updateGameStatus(`${foldMessages.join(', ')} fold(s)!`);
                    this.playersInRound = this.playersInRound.filter(p => !playersFolded.includes(p));
                }
                
                if (this.playersInRound.length === 1) {
                    this.updateGameStatus("You're the only player left! Round over.");
                    setTimeout(() => this.endRound(), 2000);
                    return;
                }
                
                let acceptedNames = this.playersInRound.filter(p => p !== 0).map(p => this.players[p].name).join(', ');
                if (acceptedNames) {
                    this.updateGameStatus(`${acceptedNames} accept(s) the toep! Continue playing.`);
                }
                
                setTimeout(() => {
                    if (this.currentPlayer !== 0) {
                        this.handleAIPlay();
                    }
                }, 1500);
                
                this.updateDisplay();
            }

            handleBlindToepResponse() {
                // Get all players except the blind toeper
                let playersToRespond = this.playersInRound.filter(p => p !== this.lastToeper);
                
                // Check if human player (index 0) needs to decide
                if (playersToRespond.includes(0)) {
                    this.showBlindToepDecisionScreen();
                    return; // Wait for human decision
                }
                
                // Handle AI-only responses
                let playersFolded = [];
                playersToRespond.forEach(playerIndex => {
                    // AI decision: 30% chance to fold to blind toep (3 stakes)
                    const foldChance = 0.3;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    }
                });
                
                this.processBlindToepResponses(playersFolded);
            }

            processBlindToepResponses(playersFolded) {
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = this.playerStakesOnEntry[p]; // Should be 3
                        this.players[p].points += penaltyPoints;
                        foldMessages.push(`${this.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    this.updateGameStatus(`${foldMessages.join(', ')} fold(s) to blind toep!`);
                    this.playersInRound = this.playersInRound.filter(p => !playersFolded.includes(p));
                }
                
                if (this.playersInRound.length === 1) {
                    this.updateGameStatus("Only one player left! Round over.");
                    setTimeout(() => this.endRound(), 2000);
                    return;
                }
                
                let acceptedNames = this.playersInRound.filter(p => p !== this.lastToeper).map(p => this.players[p].name).join(', ');
                if (acceptedNames) {
                    this.updateGameStatus(`${acceptedNames} accept(s) the blind toep! Game begins with ${this.stakes} stakes!`);
                } else {
                    this.updateGameStatus(`Blind toep accepted. Game begins with ${this.stakes} stakes!`);
                }
                
                this.pendingBlindToepResponse = false; // Reset flag
                this.updateDisplay();
            }

            showBlindToepDecisionScreen() {
                const blindToeper = this.players[this.lastToeper].name;
                
                document.getElementById('toepMessage').textContent = `${blindToeper} called Blind Toep! Stakes are now 3 points.`;
                document.getElementById('newStakes').textContent = '3';
                document.getElementById('yourEntryStakes').textContent = '3';
                document.getElementById('foldPenalty').textContent = '3';
                document.getElementById('continuePenalty').textContent = '3';
                
                this.isBlindToepDecision = true; // Mark this as blind toep decision
                document.getElementById('toepDecisionOverlay').style.display = 'block';
            }

            fold() {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== 0) return;
                
                // Player gets penalty points based on when they entered the round
                const penaltyPoints = this.playerStakesOnEntry[0];
                this.players[0].points += penaltyPoints;
                this.playersInRound = this.playersInRound.filter(p => p !== 0);
                
                this.updateGameStatus(`You fold and get ${penaltyPoints} penalty points!`);
                
                if (this.playersInRound.length === 1) {
                    this.updateGameStatus(`${this.players[this.playersInRound[0]].name} wins the round!`);
                    setTimeout(() => this.endRound(), 2000);
                    return;
                }
                
                // Continue with remaining AI players
                this.currentPlayer = this.playersInRound[0];
                setTimeout(() => {
                    if (this.currentPlayer !== 0) {
                        this.handleAIPlay();
                    }
                }, 1500);
                
                this.updateDisplay();
            }

            playCard(cardIndex) {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== 0) return;
                if (!this.playersInRound.includes(0)) return;
                if (this.isProcessing) return; // Prevent rapid clicks
                
                const card = this.players[0].hand[cardIndex];
                if (!this.isValidPlay(card)) {
                    this.updateGameStatus("Invalid play! You must follow suit if possible.");
                    return;
                }
                
                // Mark that first card has been played - no more laundry allowed
                if (!this.firstCardPlayed) {
                    this.firstCardPlayed = true;
                }
                
                this.players[0].hand.splice(cardIndex, 1);
                this.currentTrick.push({card: card, player: 0});
                
                if (this.currentTrick.length === 1) {
                    this.leadSuit = card.suit;
                }
                
                this.nextPlayer();
                
                // Set processing flag BEFORE updateDisplay to prevent rapid clicks
                this.isProcessing = true;
                this.updateDisplay();
                
                if (this.currentTrick.length < this.playersInRound.length) {
                    setTimeout(() => this.handleAIPlay(), 1500);
                } else {
                    // Trick is complete - keep processing flag true until next trick starts
                    setTimeout(() => this.evaluateTrick(), 2000);
                }
            }

            nextPlayer() {
                do {
                    this.currentPlayer = (this.currentPlayer + 1) % this.players.length;
                } while (!this.playersInRound.includes(this.currentPlayer));
            }

            handleAIPlay() {
                if (this.currentPlayer === 0 || !this.playersInRound.includes(this.currentPlayer)) return;
                
                // AI might toep occasionally on their turn (but only if they can)
                if (Math.random() < 0.12 && this.stakes < 8 && this.lastToeper !== this.currentPlayer) {
                    setTimeout(() => this.handleAIToep(), 500);
                    return;
                }
                
                const player = this.players[this.currentPlayer];
                const validCards = player.hand.filter(card => this.isValidPlay(card));
                
                // Simple AI: try to avoid winning tricks
                let cardToPlay = validCards[0];
                if (this.currentTrick.length > 0) {
                    // Try to play lowest valid card to avoid winning
                    cardToPlay = validCards.reduce((lowest, card) => 
                        card.value < lowest.value ? card : lowest
                    );
                }
                
                // Mark that first card has been played - no more laundry allowed
                if (!this.firstCardPlayed) {
                    this.firstCardPlayed = true;
                }
                
                const cardIndex = player.hand.indexOf(cardToPlay);
                player.hand.splice(cardIndex, 1);
                this.currentTrick.push({card: cardToPlay, player: this.currentPlayer});
                
                if (this.currentTrick.length === 1) {
                    this.leadSuit = cardToPlay.suit;
                }
                
                this.nextPlayer();
                this.updateDisplay();
                
                if (this.currentTrick.length < this.playersInRound.length) {
                    if (this.currentPlayer !== 0) {
                        setTimeout(() => this.handleAIPlay(), 1500);
                    } else {
                        // It's the player's turn - reset processing flag and update display
                        this.isProcessing = false;
                        this.updateDisplay();
                    }
                } else {
                    setTimeout(() => this.evaluateTrick(), 2000);
                }
            }

            handleAIToep() {
                this.stakes += 1;
                this.lastToeper = this.currentPlayer; // Mark this AI player as the last one to toep
                this.updateGameStatus(`${this.players[this.currentPlayer].name} toeps! Stakes now ${this.stakes}.`);
                
                // DON'T update stakes tracking yet - only update for players who accept
                
                // Other players (including human) might fold
                setTimeout(() => this.handleToepResponseFromAI(), 1000);
                this.updateDisplay();
            }

            handleToepResponseFromAI() {
                let playersToRespond = this.playersInRound.filter(p => p !== this.currentPlayer);
                let playersFolded = [];
                
                // Check if human player needs to decide
                if (playersToRespond.includes(0)) {
                    this.showToepDecisionScreen();
                    return; // Wait for human decision
                }
                
                // Handle AI-only responses
                let playersAccepted = [];
                playersToRespond.forEach(playerIndex => {
                    const foldChance = this.stakes >= 4 ? 0.4 : 0.25;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    } else {
                        playersAccepted.push(playerIndex);
                        // Update stakes tracking for AI players who accept
                        this.playerStakesOnEntry[playerIndex] = this.stakes;
                    }
                });
                
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = this.playerStakesOnEntry[p];
                        this.players[p].points += penaltyPoints;
                        foldMessages.push(`${this.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    this.updateGameStatus(`${foldMessages.join(', ')} fold(s)!`);
                    this.playersInRound = this.playersInRound.filter(p => !playersFolded.includes(p));
                }
                
                if (this.playersInRound.length === 1) {
                    setTimeout(() => this.endRound(), 2000);
                    return;
                }
                
                // Continue playing
                setTimeout(() => this.handleAIPlay(), 1000);
                this.updateDisplay();
            }

            isValidPlay(card) {
                if (this.currentTrick.length === 0) return true;
                
                const player = this.players[this.currentPlayer];
                const hasSuit = player.hand.some(c => c.suit === this.leadSuit);
                
                return !hasSuit || card.suit === this.leadSuit;
            }

            evaluateTrick() {
                // Always reset processing flag when trick is being evaluated
                this.isProcessing = true;
                
                let winner = this.currentTrick[0];
                
                // Find highest card of lead suit
                this.currentTrick.forEach(play => {
                    if (play.card.suit === this.leadSuit && play.card.value > winner.card.value) {
                        winner = play;
                    }
                });
                
                this.roundTrickWins[winner.player]++;
                
                this.updateGameStatus(`${this.players[winner.player].name} wins the trick!`);
                
                this.tricksPlayed++;
                this.currentTrick = [];
                this.leadSuit = null;
                
                if (this.tricksPlayed === 4) {
                    setTimeout(() => this.endRound(), 2000);
                } else {
                    this.currentPlayer = winner.player;
                    setTimeout(() => {
                        this.updateGameStatus(`${this.players[this.currentPlayer].name}'s turn to lead.`);
                        if (this.currentPlayer !== 0) {
                            setTimeout(() => this.handleAIPlay(), 1000);
                        } else {
                            // It's the player's turn to start new trick - reset processing flag
                            this.isProcessing = false;
                        }
                        this.updateDisplay(); // Update display after setting current player and processing flag
                    }, 2000);
                }
                
                // Don't call updateDisplay here - it's called inside the setTimeout
            }

            endRound() {
                // Find the player who won the most tricks (winner gets 0 points, others get penalty)
                let maxTricks = Math.max(...this.playersInRound.map(p => this.roundTrickWins[p]));
                let winners = this.playersInRound.filter(p => this.roundTrickWins[p] === maxTricks);
                
                // If there's a tie for most tricks, all tied players get 0 points
                let winnerNames = winners.map(w => this.players[w].name).join(', ');
                
                // All non-winners get penalty points equal to their entry stakes
                this.playersInRound.forEach(playerIndex => {
                    if (!winners.includes(playerIndex)) {
                        const penaltyPoints = this.playerStakesOnEntry[playerIndex];
                        this.players[playerIndex].points += penaltyPoints;
                    }
                });
                
                let roundSummary = `${winnerNames} won with ${maxTricks} tricks (0 points). Others get penalty points.`;
                this.updateGameStatus(`Round ${this.round} complete! ${roundSummary}`);
                
                // Check for eliminated players
                const eliminated = this.players.filter(p => p.points >= 10);
                if (eliminated.length > 0) {
                    let eliminatedNames = eliminated.map(p => p.name).join(', ');
                    setTimeout(() => {
                        this.updateGameStatus(`${eliminatedNames} eliminated! (10+ points)`);
                    }, 2000);
                    
                    if (this.players.filter(p => p.points < 10).length <= 1) {
                        setTimeout(() => this.endGame(), 4000);
                        return;
                    }
                }
                
                this.round++;
                this.gamePhase = 'roundEnd';
                this.blindToepCaller = -1; // Reset blind toep caller
                setTimeout(() => {
                    this.updateDisplay();
                    // Give AI players a chance to call blind toep
                    this.handleAIBlindToepDecisions();
                    // Auto-continue to next round after showing results
                    setTimeout(() => this.nextRound(), 3000);
                }, 2000);
            }

            endGame() {
                const survivors = this.players.filter(p => p.points < 10);
                if (survivors.length === 1) {
                    this.updateGameStatus(`üéâ ${survivors[0].name} wins the game! üéâ`);
                } else if (survivors.length > 1) {
                    let winnerNames = survivors.map(p => p.name).join(', ');
                    this.updateGameStatus(`üéâ ${winnerNames} survive and win! üéâ`);
                } else {
                    this.updateGameStatus(`üéâ Game over! üéâ`);
                }
                this.gamePhase = 'gameEnd';
                this.updateDisplay();
            }

            callBlindToep() {
                if (this.gamePhase !== 'roundEnd' || this.blindToepCaller >= 0) return;
                
                this.blindToepCaller = 0; // Human player calls blind toep
                this.updateGameStatus(`You called Blind Toep! Next round starts at 3 stakes.`);
                this.updateDisplay(); // Hide the blind toep button
            }

            handleAIBlindToepDecisions() {
                if (this.blindToepCaller >= 0) return; // Someone already called blind toep
                
                // Check if any AI player wants to call blind toep (10% chance)
                for (let i = 1; i < this.players.length; i++) {
                    if (this.players[i].points < 10 && Math.random() < 0.1) {
                        this.blindToepCaller = i;
                        this.updateGameStatus(`${this.players[i].name} called Blind Toep! Next round starts at 3 stakes.`);
                        break;
                    }
                }
            }

            showLaundryInspectionResult(playerIndex, actualCards, isValid) {
                // Show notification and visually display the actual cards
                const player = this.players[playerIndex];
                const playerEl = document.getElementById(`player${playerIndex}`);
                const cardsEl = playerEl.querySelector('.player-cards');
                
                // Clear current cards and show notification
                cardsEl.innerHTML = '';
                const notification = document.createElement('div');
                notification.style.cssText = 'color: #ffeb3b; font-weight: bold; margin-bottom: 10px; font-size: 0.9rem;';
                notification.textContent = `${player.name}'s actual hand was:`;
                cardsEl.appendChild(notification);
                
                // Show the actual cards they had
                actualCards.forEach(card => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `card ${card.color}`;
                    cardEl.textContent = `${card.rank}${card.suit}`;
                    cardEl.style.cssText = 'border: 2px solid #ff6b6b; animation: flash 0.5s ease-in-out;';
                    cardsEl.appendChild(cardEl);
                });
                
                // After 3 seconds, replace with new cards
                setTimeout(() => {
                    cardsEl.innerHTML = '';
                    if (isValid) {
                        // Valid claim - show cards appropriately
                        if (playerIndex === 0) {
                            // Human player should always see their own cards face-up
                            player.hand.forEach(card => {
                                const cardEl = document.createElement('div');
                                cardEl.className = `card ${card.color}`;
                                cardEl.textContent = `${card.rank}${card.suit}`;
                                cardsEl.appendChild(cardEl);
                            });
                        } else {
                            // AI players - show card backs
                            for (let i = 0; i < player.hand.length; i++) {
                                const cardEl = document.createElement('div');
                                cardEl.className = 'card card-back';
                                cardEl.textContent = 'üÇ†';
                                cardsEl.appendChild(cardEl);
                            }
                        }
                    } else {
                        // Invalid claim - new cards face up
                        player.hand.forEach(card => {
                            const cardEl = document.createElement('div');
                            cardEl.className = `card ${card.color}`;
                            cardEl.textContent = `${card.rank}${card.suit}`;
                            cardEl.style.border = '2px solid #ff6b6b'; // Red border for penalty
                            cardsEl.appendChild(cardEl);
                        });
                    }
                }, 3000);
            }

            nextRound() {
                // Check if someone called blind toep for this round
                if (this.blindToepCaller >= 0) {
                    this.stakes = 3; // Set stakes to 3 for blind toep
                    this.updateGameStatus(`${this.players[this.blindToepCaller].name} called Blind Toep! Stakes start at 3.`);
                }
                this.startRound();
            }

            updateDisplay() {
                // Update round info
                document.getElementById('roundNumber').textContent = this.round;
                document.getElementById('roundValue').textContent = this.stakes;
                document.getElementById('stakesDisplay').textContent = this.stakes;
                document.getElementById('tricksPlayed').textContent = this.tricksPlayed;
                
                // Update player displays
                this.players.forEach((player, index) => {
                    const playerEl = document.getElementById(`player${index}`);
                    if (playerEl) {
                        playerEl.querySelector('.player-name').textContent = player.name;
                        playerEl.querySelector('.player-points').textContent = `Points: ${player.points}`;
                        
                        const tricksEl = playerEl.querySelector('.player-tricks');
                        if (tricksEl) {
                            tricksEl.textContent = `This round: ${this.roundTrickWins[index] || 0} tricks`;
                        }
                        
                        const cardsEl = playerEl.querySelector('.player-cards');
                        cardsEl.innerHTML = '';
                        
                        if (index === 0) {
                            // Show human player's cards
                            player.hand.forEach((card, cardIndex) => {
                                const cardEl = document.createElement('div');
                                cardEl.className = `card ${card.color}`;
                                cardEl.textContent = `${card.rank}${card.suit}`;
                                
                                // Only add click handler and make playable if it's the player's turn and not processing
                                if (this.gamePhase === 'playing' && this.currentPlayer === 0 && 
                                    this.playersInRound.includes(0) && this.isValidPlay(card) && !this.isProcessing) {
                                    cardEl.classList.add('playable');
                                    cardEl.onclick = () => {
                                        if (isMultiplayer) {
                                            if (!this.isProcessing) {
                                                this.isProcessing = true; // Prevent multiple clicks
                                                // Immediately disable all card clicks
                                                this.players[0].hand.forEach((_, idx) => {
                                                    const cardToDisable = document.querySelector(`#yourCards .card:nth-child(${idx + 1})`);
                                                    if (cardToDisable) {
                                                        cardToDisable.onclick = null;
                                                        cardToDisable.style.cursor = 'not-allowed';
                                                        cardToDisable.style.opacity = '0.6';
                                                    }
                                                });
                                                socket.emit('gameAction', { type: 'playCard', cardIndex: cardIndex });
                                            }
                                        } else {
                                            if (!this.isProcessing) {
                                                this.playCard(cardIndex);
                                            }
                                        }
                                    };
                                    cardEl.style.cursor = 'pointer';
                                } else {
                                    cardEl.style.cursor = 'not-allowed';
                                    cardEl.style.opacity = this.currentPlayer === 0 ? '0.6' : '0.3';
                                }
                                
                                cardsEl.appendChild(cardEl);
                            });
                        } else if (this.playersInRound.includes(index)) {
                            // Show cards for AI players still in the round
                            if (player.cardsVisible) {
                                // Show face-up cards for players with invalid laundry penalty
                                player.hand.forEach(card => {
                                    const cardEl = document.createElement('div');
                                    cardEl.className = `card ${card.color}`;
                                    cardEl.textContent = `${card.rank}${card.suit}`;
                                    cardEl.style.border = '2px solid #ff6b6b'; // Red border for penalty
                                    cardsEl.appendChild(cardEl);
                                });
                            } else {
                                // Show card backs for normal AI players
                                for (let i = 0; i < player.hand.length; i++) {
                                    const cardEl = document.createElement('div');
                                    cardEl.className = 'card card-back';
                                    cardEl.textContent = 'üÇ†';
                                    cardsEl.appendChild(cardEl);
                                }
                            }
                        } else {
                            // Show empty space for folded players
                            const foldedEl = document.createElement('div');
                            foldedEl.textContent = 'FOLDED';
                            foldedEl.style.color = '#ff6b6b';
                            foldedEl.style.fontWeight = 'bold';
                            cardsEl.appendChild(foldedEl);
                        }
                        
                        // Highlight active player
                        playerEl.classList.toggle('active', this.currentPlayer === index && this.gamePhase === 'playing');
                        
                        // Show eliminated players
                        playerEl.classList.toggle('eliminated', player.points >= 10);
                        
                        // Laundry inspection - make claimer clickable for inspection
                        if (this.awaitingInspection && this.pendingLaundry) {
                            if (this.pendingLaundry.playerIndex === index) {
                                // This is the claimer - make clickable for others to inspect
                                playerEl.style.cursor = 'pointer';
                                playerEl.style.border = '3px solid #ffeb3b';
                                playerEl.title = `Claims ${this.pendingLaundry.type === 'witte' ? 'Witte was' : 'Vuile was'} - Click to inspect!`;
                                
                                // In multiplayer, only the human player (index 0) can click to inspect
                                if (index !== 0 && isMultiplayer) {
                                    // This is the claimer for the human player - allow clicking
                                    playerEl.onclick = () => {
                                        socket.emit('gameAction', { type: 'inspectLaundry' });
                                    };
                                } else if (!isMultiplayer) {
                                    // Singleplayer - human can inspect any claimer
                                    playerEl.onclick = () => {
                                        this.inspectLaundry(0);
                                    };
                                } else {
                                    // This is the human player themselves claiming - can't inspect self
                                    playerEl.style.cursor = 'default';
                                    playerEl.title = `You claim ${this.pendingLaundry.type === 'witte' ? 'Witte was' : 'Vuile was'} - waiting for inspection`;
                                    playerEl.onclick = null;
                                }
                            } else {
                                // This is not the claimer - show normal appearance
                                playerEl.style.cursor = 'default';
                                playerEl.style.border = 'none';
                                playerEl.title = '';
                                playerEl.onclick = null;
                                
                                // Other AI players can inspect too (simulate) - reduced chance
                                if (Math.random() < 0.03) { // 3% chance AI inspects (rare but possible)
                                    setTimeout(() => this.inspectLaundry(index), Math.random() * 5000 + 2000);
                                }
                            }
                        } else {
                            playerEl.style.cursor = 'default';
                            playerEl.style.border = 'none';
                            playerEl.title = '';
                            playerEl.onclick = null;
                        }
                        
                        // Show if player folded this round
                        if (!this.playersInRound.includes(index) && this.gamePhase === 'playing') {
                            playerEl.style.opacity = '0.6';
                        } else {
                            playerEl.style.opacity = '1';
                        }
                    }
                });
                
                // Update trick area
                const trickArea = document.getElementById('trickArea');
                trickArea.innerHTML = '';
                this.currentTrick.forEach(play => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `played-card ${play.card.color}`;
                    
                    // Create card content with proper structure
                    const cardContent = document.createElement('div');
                    cardContent.textContent = `${play.card.rank}${play.card.suit}`;
                    cardContent.style.fontSize = '1.2rem';
                    cardContent.style.fontWeight = 'bold';
                    
                    cardEl.appendChild(cardContent);
                    cardEl.setAttribute('data-player', this.players[play.player].name);
                    
                    // Highlight the winning card if trick is complete
                    if (this.currentTrick.length === this.playersInRound.length) {
                        let winner = this.currentTrick[0];
                        this.currentTrick.forEach(p => {
                            if (p.card.suit === this.leadSuit && p.card.value > winner.card.value) {
                                winner = p;
                            }
                        });
                        if (play === winner) {
                            cardEl.classList.add('winning');
                        }
                    }
                    
                    trickArea.appendChild(cardEl);
                });
                
                // Update controls
                const toepBtn = document.getElementById('toepBtn');
                const foldBtn = document.getElementById('foldBtn');
                const vuileWasBtn = document.getElementById('vuileWasBtn');
                const witteWasBtn = document.getElementById('witteWasBtn');
                const blindToepBtn = document.getElementById('blindToepBtn');
                
                const canToep = this.gamePhase === 'playing' && this.currentPlayer === 0 && 
                              this.playersInRound.includes(0) && this.stakes < 16 && this.lastToeper !== 0;
                const canFold = this.gamePhase === 'playing' && this.playersInRound.includes(0);
                
                // Laundry buttons visibility - only show during laundry phase when not awaiting inspection
                const inLaundryPhase = this.gamePhase === 'laundry' && !this.awaitingInspection;
                const canSubmitVuileWas = inLaundryPhase;
                const canSubmitWitteWas = inLaundryPhase;
                
                // Blind toep button - show during roundEnd phase
                const canBlindToep = this.gamePhase === 'roundEnd' && this.blindToepCaller === -1;
                
                toepBtn.style.display = canToep ? 'inline-block' : 'none';
                foldBtn.style.display = canFold ? 'inline-block' : 'none';
                vuileWasBtn.style.display = canSubmitVuileWas ? 'inline-block' : 'none';
                witteWasBtn.style.display = canSubmitWitteWas ? 'inline-block' : 'none';
                blindToepBtn.style.display = canBlindToep ? 'inline-block' : 'none';
                
                // Show game menu in multiplayer
                const gameMenu = document.getElementById('gameMenu');
                gameMenu.style.display = isMultiplayer ? 'block' : 'none';
                
                toepBtn.disabled = !canToep;
                foldBtn.disabled = !canFold;
            }

            updateGameStatus(message) {
                document.getElementById('gameStatus').textContent = message;
            }

            showToepDecisionScreen() {
                const toepper = this.players[this.currentPlayer].name;
                const yourEntryStakes = this.playerStakesOnEntry[0];
                
                document.getElementById('toepMessage').textContent = `${toepper} toeps! Stakes raised to ${this.stakes} points.`;
                document.getElementById('newStakes').textContent = this.stakes;
                document.getElementById('yourEntryStakes').textContent = yourEntryStakes;
                document.getElementById('foldPenalty').textContent = yourEntryStakes;
                document.getElementById('continuePenalty').textContent = this.stakes;
                
                this.isBlindToepDecision = false; // Mark this as regular toep decision
                document.getElementById('toepDecisionOverlay').style.display = 'block';
            }

            showBlindToepDecisionScreen(blindToeper) {
                const toepperName = this.players[blindToeper]?.name || 'Unknown';
                
                document.getElementById('toepMessage').textContent = `${toepperName} calls blind toep! Stakes set to 3 points.`;
                document.getElementById('newStakes').textContent = '3';
                document.getElementById('yourEntryStakes').textContent = '1';
                document.getElementById('foldPenalty').textContent = '1'; // Fold penalty is your entry stakes (1 point)
                document.getElementById('continuePenalty').textContent = '3'; // If you continue and lose, you get 3 points
                
                this.isBlindToepDecision = true; // Mark this as blind toep decision
                document.getElementById('toepDecisionOverlay').style.display = 'block';
            }

            hideToepDecisionScreen() {
                document.getElementById('toepDecisionOverlay').style.display = 'none';
                this.isBlindToepDecision = false; // Reset flag
            }
        }

        let game = new ToepenGame();
        let currentLobby = null;
        
        // Initialize Socket.io connection
        const socket = io();
        let isMultiplayer = false;
        let myPlayerIndex = -1;
        
        // Socket event handlers
        socket.on('roomCreated', (data) => {
            currentLobby = {
                code: data.roomCode,
                players: data.players,
                isHost: true
            };
            
            document.getElementById('currentLobbyCode').textContent = data.roomCode;
            document.getElementById('lobbyPlayers').style.display = 'block';
            document.getElementById('startGameBtn').style.display = 'inline-block';
            updateLobbyDisplay();
        });
        
        socket.on('roomJoined', (data) => {
            currentLobby = {
                code: data.roomCode,
                players: data.players,
                isHost: data.isHost
            };
            
            document.getElementById('currentLobbyCode').textContent = data.roomCode;
            document.getElementById('lobbyPlayers').style.display = 'block';
            document.getElementById('startGameBtn').style.display = data.isHost ? 'inline-block' : 'none';
            updateLobbyDisplay();
            showMessage(`Joined lobby ${data.roomCode}!`);
        });
        
        socket.on('playerJoined', (data) => {
            if (currentLobby) {
                currentLobby.players = data.players;
                updateLobbyDisplay();
                showMessage(`${data.joinedPlayer} joined the lobby!`);
                addActivityMessage(`üì• ${data.joinedPlayer} joined the lobby`, 'player-event');
            }
        });
        
        socket.on('gameStarted', (data) => {
            isMultiplayer = true;
            myPlayerIndex = data.gameState.players.findIndex(p => p.id === socket.id);
            
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // Create dynamic layout based on player count
            createPlayersLayout(data.gameState.players.length);
            
            // Initialize activity log for multiplayer
            enhanceGameStatusUpdate();
            addActivityMessage(`üéÆ Game started with ${data.gameState.players.length} players!`, 'game-event');
            
            // Sync with the server's initial game state (cards already dealt)
            syncGameState(data.gameState);
        });
        
        socket.on('gameStateUpdate', (data) => {
            if (isMultiplayer) {
                syncGameState(data.gameState);
                
                // Handle game event messages
                if (data.lastAction) {
                    // Convert action player indices from server perspective to client perspective
                    const convertedAction = { ...data.lastAction };
                    const myServerIndex = data.gameState.players.findIndex(p => p.id === socket.id);
                    
                    if (convertedAction.claimerIndex !== undefined) {
                        convertedAction.claimerIndex = (convertedAction.claimerIndex - myServerIndex + data.gameState.players.length) % data.gameState.players.length;
                    }
                    if (convertedAction.playerIndex !== undefined) {
                        convertedAction.playerIndex = (convertedAction.playerIndex - myServerIndex + data.gameState.players.length) % data.gameState.players.length;
                    }
                    
                    handleGameEvent(convertedAction, data.gameState);
                }
            }
        });
        
        socket.on('joinError', (error) => {
            alert(`Failed to join lobby: ${error}`);
        });
        
        socket.on('playerLeft', (data) => {
            // Update lobby display if we're in lobby mode
            if (currentLobby && !isMultiplayer) {
                currentLobby.players = data.players;
                // Update host status if there's a new host
                if (data.newHost === socket.id) {
                    currentLobby.isHost = true;
                }
                updateLobbyDisplay();
                showMessage(`${data.playerName} left the lobby`);
            }
            
            // Update game display if we're in a multiplayer game
            if (isMultiplayer) {
                game.updateGameStatus(`üì§ ${data.playerName} left the game`);
                addActivityMessage(`üì§ ${data.playerName} left the game`, 'player-event');
            }
        });
        
        socket.on('error', (error) => {
            alert(`Error: ${error}`);
        });
        
        function showMessage(text) {
            // Simple message display - you can enhance this
            const status = document.getElementById('gameStatus');
            if (status) {
                status.textContent = text;
            }
        }
        
        function handleGameEvent(action, gameState) {
            switch (action.type) {
                case 'playCard':
                    const playerName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${playerName} played a card.`);
                    break;
                case 'trickComplete':
                    if (gameState.lastTrickWinner) {
                        game.updateGameStatus(`${gameState.lastTrickWinner} wins the trick!`);
                    }
                    break;
                case 'toep':
                    const toepperName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${toepperName} toeps! Stakes raised to ${gameState.stakes}.`);
                    break;
                case 'acceptToep':
                    const accepterName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${accepterName} accepts the toep.`);
                    break;
                case 'foldToToep':
                    const folderName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${folderName} folds to the toep.`);
                    break;
                case 'submitLaundry':
                    const laundryPlayer = gameState.players[action.playerIndex]?.name || 'Unknown';
                    const laundryType = action.laundryType === 'witte' ? 'Witte was' : 'Vuile was';
                    game.updateGameStatus(`${laundryPlayer} claims ${laundryType}! Click to inspect or wait.`);
                    break;
                case 'laundryTimeout':
                    const timeoutPlayer = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`No one inspected ${timeoutPlayer}'s claim. ${timeoutPlayer} gets new cards.`);
                    break;
                case 'laundryInspected':
                    const inspector = gameState.players[action.playerIndex]?.name || 'Unknown';
                    const claimer = gameState.players[action.claimerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${inspector} inspects ${claimer}'s laundry claim...`);
                    
                    // Show detailed result if available
                    if (gameState.laundryResult) {
                        const result = gameState.laundryResult;
                        const resultText = result.claimType === 'witte' ? 'Witte was' : 'Vuile was';
                        
                        setTimeout(() => {
                            if (result.type === 'validClaim') {
                                game.updateGameStatus(`‚úÖ ${claimer} had valid ${resultText}! ${inspector} gets 1 penalty point. ${claimer} gets new cards.`);
                                if (result.actualCards) {
                                    game.showLaundryInspectionResult(action.claimerIndex, result.actualCards, true);
                                }
                            } else {
                                game.updateGameStatus(`‚ùå ${claimer} was bluffing ${resultText}! ${claimer} gets 1 penalty point and visible cards.`);
                                if (result.actualCards) {
                                    game.showLaundryInspectionResult(action.claimerIndex, result.actualCards, false);
                                }
                            }
                        }, 1500);
                    }
                    break;
                case 'laundryPhaseEnd':
                    game.updateGameStatus(`Laundry phase ended. Game begins!`);
                    break;
                case 'newRound':
                    game.updateGameStatus(`Round ${gameState.round} begins! Check for laundry.`);
                    break;
                case 'toepResponsesComplete':
                    game.updateGameStatus(`All players responded to toep. Continuing game.`);
                    break;
                case 'blindToepResponse':
                    const blindToeper = gameState.players[action.blindToeper]?.name || 'Unknown';
                    game.updateGameStatus(`${blindToeper} called blind toep! Choose to continue for 3 points or fold.`);
                    break;
                case 'acceptBlindToep':
                    const blindAccepterName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${blindAccepterName} accepts blind toep.`);
                    break;
                case 'foldToBlindToep':
                    const blindFolderName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${blindFolderName} folds to blind toep.`);
                    break;
                case 'blindToepResponsesComplete':
                    game.updateGameStatus(`All players responded to blind toep. Game begins with ${gameState.stakes} stakes.`);
                    break;
                case 'blindToepProcessed':
                    if (action.playersFolded && action.playersFolded.length > 0) {
                        const foldedNames = action.playersFolded.map(i => gameState.players[i]?.name || 'Unknown').join(', ');
                        game.updateGameStatus(`${foldedNames} fold(s) to blind toep! Game begins with ${gameState.stakes} stakes.`);
                    } else {
                        game.updateGameStatus(`Blind toep accepted by all players! Game begins with ${gameState.stakes} stakes.`);
                    }
                    break;
            }
        }
        
        function syncGameState(serverState) {
            // Find this player's index in the server state
            const myServerIndex = serverState.players.findIndex(p => p.id === socket.id);
            if (myServerIndex === -1) return;
            
            // Reorder players so this player is always index 0 (bottom of screen)
            const reorderedPlayers = [];
            for (let i = 0; i < serverState.players.length; i++) {
                const serverIndex = (myServerIndex + i) % serverState.players.length;
                const serverPlayer = serverState.players[serverIndex];
                reorderedPlayers.push({
                    name: serverPlayer.name,
                    points: serverPlayer.points,
                    hand: serverPlayer.hand,
                    isBot: false,
                    cardsVisible: serverPlayer.cardsVisible || false
                });
            }
            
            game.players = reorderedPlayers;
            
            // Convert server current player index to local perspective
            game.currentPlayer = (serverState.currentPlayer - myServerIndex + serverState.players.length) % serverState.players.length;
            
            // Convert other indices that reference players
            game.lastToeper = serverState.lastToeper === -1 ? -1 : 
                (serverState.lastToeper - myServerIndex + serverState.players.length) % serverState.players.length;
            
            // Handle playersInRound array
            game.playersInRound = serverState.playersInRound.map(serverIndex => 
                (serverIndex - myServerIndex + serverState.players.length) % serverState.players.length
            );
            
            // Handle roundTrickWins array
            game.roundTrickWins = [];
            for (let i = 0; i < serverState.players.length; i++) {
                const serverIndex = (myServerIndex + i) % serverState.players.length;
                game.roundTrickWins[i] = serverState.roundTrickWins[serverIndex] || 0;
            }
            
            // Handle playerStakesOnEntry array
            game.playerStakesOnEntry = [];
            for (let i = 0; i < serverState.players.length; i++) {
                const serverIndex = (myServerIndex + i) % serverState.players.length;
                game.playerStakesOnEntry[i] = serverState.playerStakesOnEntry[serverIndex] || 1;
            }
            
            // Convert current trick player indices
            game.currentTrick = serverState.currentTrick.map(play => ({
                card: play.card,
                player: (play.player - myServerIndex + serverState.players.length) % serverState.players.length
            }));
            
            // Simple properties that don't need conversion
            game.round = serverState.round;
            game.stakes = serverState.stakes;
            game.gamePhase = serverState.gamePhase;
            game.awaitingInspection = serverState.awaitingInspection;
            game.tricksPlayed = serverState.tricksPlayed;
            game.leadSuit = serverState.leadSuit;
            
            // Handle toep responses (if exists)
            if (serverState.toepResponses) {
                game.toepResponses = [];
                for (let i = 0; i < serverState.players.length; i++) {
                    const serverIndex = (myServerIndex + i) % serverState.players.length;
                    game.toepResponses[i] = serverState.toepResponses[serverIndex];
                }
            } else {
                game.toepResponses = null;
            }
            
            // Handle blind toep responses (if exists)
            if (serverState.blindToepResponses) {
                game.blindToepResponses = [];
                for (let i = 0; i < serverState.players.length; i++) {
                    const serverIndex = (myServerIndex + i) % serverState.players.length;
                    game.blindToepResponses[i] = serverState.blindToepResponses[serverIndex];
                }
            } else {
                game.blindToepResponses = null;
            }
            
            // Handle pending laundry
            if (serverState.pendingLaundry) {
                game.pendingLaundry = {
                    ...serverState.pendingLaundry,
                    playerIndex: (serverState.pendingLaundry.playerIndex - myServerIndex + serverState.players.length) % serverState.players.length
                };
            } else {
                game.pendingLaundry = null;
            }
            
            // Show/hide toep decision screen based on game state
            if (serverState.gamePhase === 'toepResponse' && 
                serverState.toepResponses && 
                serverState.toepResponses[myServerIndex] === null &&
                serverState.playersInRound.includes(myServerIndex)) {
                game.showToepDecisionScreen();
            } else if (serverState.gamePhase === 'blindToepResponse' && 
                       serverState.blindToepResponses && 
                       serverState.blindToepResponses[myServerIndex] === null &&
                       serverState.playersInRound.includes(myServerIndex)) {
                // Convert server blindToeper index to client perspective
                const clientBlindToeper = (serverState.lastToeper - myServerIndex + serverState.players.length) % serverState.players.length;
                game.showBlindToepDecisionScreen(clientBlindToeper);
            } else {
                // Hide toep decision overlay if it's showing and no longer needed
                if (document.getElementById('toepDecisionOverlay').style.display !== 'none') {
                    game.hideToepDecisionScreen();
                }
            }
            
            // Reset processing flag when receiving server updates (allows new actions)
            // But only if the trick isn't complete (to prevent multiple card plays on last card)
            if (game.gamePhase === 'playing' && game.currentPlayer === 0 && 
                game.currentTrick.length < game.playersInRound.length) {
                game.isProcessing = false;
            }
            
            game.updateDisplay();
        }

        function showLobby() {
            // Clear any old lobby state first
            currentLobby = null;
            document.getElementById('lobbyPlayers').style.display = 'none';
            document.getElementById('lobbyCode').value = '';
            document.getElementById('currentLobbyCode').textContent = '';
            document.getElementById('playersList').innerHTML = '';
            
            // Ensure socket is connected
            if (!socket.connected) {
                socket.connect();
            }
            
            // Sync name from setup screen to lobby screen
            const setupName = document.getElementById('playerName').value || 'Player';
            document.getElementById('lobbyPlayerName').value = setupName;
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
        }

        function backToSetup() {
            // Sync name back from lobby screen to setup screen
            const lobbyName = document.getElementById('lobbyPlayerName').value || 'Player';
            document.getElementById('playerName').value = lobbyName;
            
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('setupScreen').style.display = 'block';
        }

        function createLobby() {
            const playerName = document.getElementById('lobbyPlayerName').value || 'Player';
            
            if (!playerName.trim()) {
                alert('Please enter your name!');
                return;
            }
            
            // Send create room request to server
            socket.emit('createRoom', playerName);
        }

        function joinLobby() {
            const playerName = document.getElementById('lobbyPlayerName').value || 'Player';
            const lobbyCode = document.getElementById('lobbyCode').value.toUpperCase();
            
            if (!lobbyCode) {
                alert('Please enter a lobby code!');
                return;
            }
            
            if (!playerName.trim()) {
                alert('Please enter your name!');
                return;
            }
            
            // Send join room request to server
            socket.emit('joinRoom', { roomCode: lobbyCode, playerName: playerName });
        }

        function addBot() {
            if (!currentLobby || currentLobby.players.length >= currentLobby.maxPlayers) return;
            
            const botNumber = currentLobby.players.filter(p => p.isBot).length + 1;
            currentLobby.players.push({
                name: `Bot ${botNumber}`,
                isBot: true,
                isHost: false
            });
            
            updateLobbyDisplay();
        }

        function leaveLobby() {
            // Disconnect from socket to properly remove from server lobby
            if (socket && socket.connected) {
                socket.disconnect();
                socket.connect(); // Reconnect for future use
            }
            
            currentLobby = null;
            game.lobbyCode = '';
            game.isHost = false;
            
            document.getElementById('lobbyPlayers').style.display = 'none';
            document.getElementById('lobbyCode').value = '';
            backToSetup();
        }

        function copyLobbyCode() {
            const lobbyCode = document.getElementById('currentLobbyCode').textContent;
            if (lobbyCode) {
                navigator.clipboard.writeText(lobbyCode).then(() => {
                    // Provide visual feedback that the code was copied
                    const button = event.target;
                    const originalText = button.textContent;
                    button.textContent = 'Copied!';
                    button.style.background = '#4CAF50';
                    
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '';
                    }, 1500);
                }).catch(() => {
                    // Fallback for older browsers
                    alert('Lobby code: ' + lobbyCode);
                });
            }
        }

        function startLobbyGame() {
            if (!currentLobby || !currentLobby.isHost) return;
            
            if (currentLobby.players.length < 2) {
                alert('Need at least 2 players to start the game!');
                return;
            }
            
            // Send start game request to server
            socket.emit('startGame');
        }

        function updateLobbyDisplay() {
            if (!currentLobby) return;
            
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';
            
            currentLobby.players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = 'padding: 10px; margin: 5px; background: rgba(255,255,255,0.1); border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                
                const playerInfo = document.createElement('span');
                playerInfo.textContent = `${player.name} ${player.isHost ? '(Host)' : ''} ${player.isBot ? '(Bot)' : ''}`;
                
                playerDiv.appendChild(playerInfo);
                
                if (player.isBot && currentLobby.isHost) {
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'Remove';
                    removeBtn.className = 'btn btn-danger';
                    removeBtn.style.cssText = 'padding: 5px 10px; font-size: 0.8rem;';
                    removeBtn.onclick = () => removeBot(index);
                    playerDiv.appendChild(removeBtn);
                }
                
                playersList.appendChild(playerDiv);
            });
            
            const addBotBtn = document.getElementById('addBotBtn');
            addBotBtn.style.display = (currentLobby.players.length < currentLobby.maxPlayers && currentLobby.isHost) ? 'inline-block' : 'none';
            
            const startBtn = document.getElementById('startGameBtn');
            startBtn.style.display = (currentLobby.players.length >= 2 && currentLobby.isHost) ? 'inline-block' : 'none';
            
            const waitingMsg = document.getElementById('waitingMessage');
            waitingMsg.style.display = (currentLobby.players.length >= 2 && !currentLobby.isHost) ? 'block' : 'none';
        }

        function removeBot(index) {
            if (!currentLobby || !currentLobby.players[index].isBot || !currentLobby.isHost) return;
            
            currentLobby.players.splice(index, 1);
            updateLobbyDisplay();
        }

        function generateLobbyCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function startGame() {
            const playerName = document.getElementById('playerName').value || 'Player';
            const numPlayers = parseInt(document.getElementById('numPlayers').value);
            
            game.players = [{name: playerName, points: 0, hand: []}];
            
            for (let i = 1; i < numPlayers; i++) {
                game.players.push({name: `Player ${i + 1}`, points: 0, hand: []});
            }
            
            // Create dynamic layout for singleplayer
            createPlayersLayout(numPlayers);
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            game.startRound();
        }

        function toep() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'toep' });
            } else {
                game.toep();
            }
        }

        function fold() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'fold' });
            } else {
                game.fold();
            }
        }

        function callBlindToep() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'blindToep' });
            } else {
                game.callBlindToep();
            }
        }

        function acceptToep() {
            if (isMultiplayer) {
                // Check if this is a blind toep decision
                if (game.isBlindToepDecision) {
                    socket.emit('gameAction', { type: 'acceptToep' }); // Server handles blind vs regular toep
                } else {
                    socket.emit('gameAction', { type: 'acceptToep' });
                }
                game.hideToepDecisionScreen();
            } else {
                game.hideToepDecisionScreen();
                
                // Update stakes tracking for human player who accepts
                game.playerStakesOnEntry[0] = game.stakes;
                
                // Continue with AI responses for other players
                let playersToRespond = game.playersInRound.filter(p => p !== game.currentPlayer && p !== 0);
                let playersFolded = [];
                let playersAccepted = [];
                
                playersToRespond.forEach(playerIndex => {
                    const foldChance = game.stakes >= 4 ? 0.4 : 0.25;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    } else {
                        playersAccepted.push(playerIndex);
                        // Update stakes tracking for AI players who accept
                        game.playerStakesOnEntry[playerIndex] = game.stakes;
                    }
                });
                
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = game.playerStakesOnEntry[p];
                        game.players[p].points += penaltyPoints;
                        foldMessages.push(`${game.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    game.updateGameStatus(`You accept! ${foldMessages.join(', ')} fold(s)!`);
                    game.playersInRound = game.playersInRound.filter(p => !playersFolded.includes(p));
                } else {
                    game.updateGameStatus(`You accept the toep! All players continue.`);
                }
                
                if (game.playersInRound.length === 1) {
                    setTimeout(() => game.endRound(), 2000);
                    return;
                }
                
                // Continue playing
                setTimeout(() => {
                    if (game.currentPlayer !== 0) {
                        game.handleAIPlay();
                    }
                }, 1500);
                
                game.updateDisplay();
            }
        }

        function foldToToep() {
            if (isMultiplayer) {
                // Check if this is a blind toep decision
                if (game.isBlindToepDecision) {
                    socket.emit('gameAction', { type: 'foldToToep' }); // Server handles blind vs regular toep
                } else {
                    socket.emit('gameAction', { type: 'foldToToep' });
                }
                game.hideToepDecisionScreen();
            } else {
                game.hideToepDecisionScreen();
                
                // Player folds - gets penalty points based on entry stakes
                const penaltyPoints = game.playerStakesOnEntry[0];
                game.players[0].points += penaltyPoints;
                game.playersInRound = game.playersInRound.filter(p => p !== 0);
                
                game.updateGameStatus(`You fold and get ${penaltyPoints} penalty points!`);
                
                // Continue with other AI responses
                let playersToRespond = game.playersInRound.filter(p => p !== game.currentPlayer);
                let playersFolded = [];
                let playersAccepted = [];
                
                playersToRespond.forEach(playerIndex => {
                    const foldChance = game.stakes >= 4 ? 0.4 : 0.25;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    } else {
                        playersAccepted.push(playerIndex);
                        // Update stakes tracking for AI players who accept
                        game.playerStakesOnEntry[playerIndex] = game.stakes;
                    }
                });
                
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = game.playerStakesOnEntry[p];
                        game.players[p].points += penaltyPoints;
                        foldMessages.push(`${game.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    setTimeout(() => {
                        game.updateGameStatus(`${foldMessages.join(', ')} also fold(s)!`);
                        game.playersInRound = game.playersInRound.filter(p => !playersFolded.includes(p));
                        
                        if (game.playersInRound.length === 1) {
                            game.updateGameStatus(`${game.players[game.playersInRound[0]].name} wins the round!`);
                            setTimeout(() => game.endRound(), 2000);
                            return;
                        }
                        
                        // Continue with remaining players
                        game.currentPlayer = game.playersInRound[0];
                        setTimeout(() => game.handleAIPlay(), 1000);
                        game.updateDisplay();
                    }, 1000);
                } else {
                    if (game.playersInRound.length === 1) {
                        game.updateGameStatus(`${game.players[game.playersInRound[0]].name} wins the round!`);
                        setTimeout(() => game.endRound(), 2000);
                        return;
                    }
                    
                    // Continue with remaining players
                    setTimeout(() => {
                        if (game.currentPlayer !== 0) {
                            game.handleAIPlay();
                        }
                    }, 1500);
                }
                
                game.updateDisplay();
            }
        }

        function submitVuileWas() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'submitLaundry', laundryType: 'vuile' });
            } else {
                if (game.gamePhase !== 'laundry' || game.awaitingInspection) return;
                game.submitLaundry(0, 'vuile');
            }
        }

        function submitWitteWas() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'submitLaundry', laundryType: 'witte' });
            } else {
                if (game.gamePhase !== 'laundry' || game.awaitingInspection) return;
                game.submitLaundry(0, 'witte');
            }
        }

        // Activity Log Functions
        function toggleActivityLog() {
            const log = document.getElementById('activityLog');
            const toggle = document.querySelector('.activity-toggle');
            
            if (log.style.display === 'none' || log.style.display === '') {
                log.style.display = 'block';
                toggle.style.display = 'none';
            } else {
                log.style.display = 'none';
                toggle.style.display = 'block';
            }
        }

        function addActivityMessage(message, type = 'game-event') {
            const messages = document.getElementById('activityMessages');
            const messageEl = document.createElement('div');
            messageEl.className = `activity-message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit' 
            });
            
            messageEl.innerHTML = `<span style="color: #999; font-size: 0.8rem;">[${timestamp}]</span> ${message}`;
            messages.appendChild(messageEl);
            
            // Auto-scroll to bottom
            messages.scrollTop = messages.scrollHeight;
            
            // Keep only last 50 messages
            while (messages.children.length > 50) {
                messages.removeChild(messages.firstChild);
            }
        }

        function returnToMainMenu() {
            if (confirm('Return to main menu? This will end the current game.')) {
                // Disconnect from multiplayer if connected
                if (isMultiplayer && socket) {
                    socket.disconnect();
                }
                
                // Reset all game state
                isMultiplayer = false;
                myPlayerIndex = -1;
                currentLobby = null;
                
                // Hide all screens and show setup
                document.getElementById('gameScreen').style.display = 'none';
                document.getElementById('lobbyScreen').style.display = 'none';
                document.getElementById('setupScreen').style.display = 'block';
                
                // Reset game
                game = new ToepenGame();
                
                // Clear activity log
                document.getElementById('activityMessages').innerHTML = '';
                
                addActivityMessage('üè† Returned to main menu', 'player-event');
            }
        }

        // Dynamic UI Layout Functions
        function createPlayersLayout(playerCount) {
            const playersSection = document.getElementById('playersSection');
            playersSection.innerHTML = '';
            playersSection.className = `players-section players-${playerCount}`;
            
            if (playerCount === 2) {
                // 2 players: opponent on left, center area on right
                playersSection.innerHTML = `
                    <div id="player1" class="player" style="grid-area: opponent1;">
                        <div class="player-name">Player 2</div>
                        <div class="player-points">Points: 0</div>
                        <div class="player-tricks">This round: 0 tricks</div>
                        <div class="player-cards"></div>
                    </div>
                    <div class="playing-area" style="grid-area: center;">
                        <div class="trick-area" id="trickArea"></div>
                        <div class="stakes-indicator">Stakes: <span id="stakesDisplay">1</span> points</div>
                        <div class="game-status" id="gameStatus">Round starting...</div>
                    </div>
                `;
            } else if (playerCount === 3) {
                // 3 players: classic layout
                playersSection.innerHTML = `
                    <div id="player1" class="player" style="grid-area: opponent1;">
                        <div class="player-name">Player 2</div>
                        <div class="player-points">Points: 0</div>
                        <div class="player-tricks">This round: 0 tricks</div>
                        <div class="player-cards"></div>
                    </div>
                    <div class="playing-area" style="grid-area: center;">
                        <div class="trick-area" id="trickArea"></div>
                        <div class="stakes-indicator">Stakes: <span id="stakesDisplay">1</span> points</div>
                        <div class="game-status" id="gameStatus">Round starting...</div>
                    </div>
                    <div id="player2" class="player" style="grid-area: opponent2;">
                        <div class="player-name">Player 3</div>
                        <div class="player-points">Points: 0</div>
                        <div class="player-tricks">This round: 0 tricks</div>
                        <div class="player-cards"></div>
                    </div>
                `;
            } else if (playerCount === 4) {
                // 4 players: 3 opponents on top, center below
                playersSection.innerHTML = `
                    <div id="player1" class="player" style="grid-area: opponent1;">
                        <div class="player-name">Player 2</div>
                        <div class="player-points">Points: 0</div>
                        <div class="player-tricks">This round: 0 tricks</div>
                        <div class="player-cards"></div>
                    </div>
                    <div id="player2" class="player" style="grid-area: opponent2;">
                        <div class="player-name">Player 3</div>
                        <div class="player-points">Points: 0</div>
                        <div class="player-tricks">This round: 0 tricks</div>
                        <div class="player-cards"></div>
                    </div>
                    <div id="player3" class="player" style="grid-area: opponent3;">
                        <div class="player-name">Player 4</div>
                        <div class="player-points">Points: 0</div>
                        <div class="player-tricks">This round: 0 tricks</div>
                        <div class="player-cards"></div>
                    </div>
                    <div class="playing-area" style="grid-area: center;">
                        <div class="trick-area" id="trickArea"></div>
                        <div class="stakes-indicator">Stakes: <span id="stakesDisplay">1</span> points</div>
                        <div class="game-status" id="gameStatus">Round starting...</div>
                    </div>
                `;
            }
        }

        // Enhanced status update function that also logs to activity
        const originalUpdateGameStatus = game ? game.updateGameStatus : null;
        
        // Track already logged messages to prevent duplicates
        let recentActivityMessages = new Set();
        
        // Override updateGameStatus to also log to activity log (prevent duplicates)
        function enhanceGameStatusUpdate() {
            if (game && game.updateGameStatus) {
                const original = game.updateGameStatus.bind(game);
                game.updateGameStatus = function(message) {
                    original(message);
                    
                    // Only log to activity if multiplayer and not a duplicate
                    if (isMultiplayer && !recentActivityMessages.has(message)) {
                        // Skip messages that are handled by specific socket events
                        if (!message.includes('left the game') && 
                            !message.includes('joined the lobby') && 
                            !message.includes('Game started')) {
                            addActivityMessage(message, 'game-event');
                            recentActivityMessages.add(message);
                            // Clear old messages after 5 seconds
                            setTimeout(() => recentActivityMessages.delete(message), 5000);
                        }
                    }
                };
            }
        }

        // Initialize activity log when game starts
        if (typeof game !== 'undefined') {
            enhanceGameStatusUpdate();
        }

    </script>
</body>
</html>