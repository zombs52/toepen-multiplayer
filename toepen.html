<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toepen - Dutch Card Game</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .players-section {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
            min-height: 200px;
        }

        .player {
            background: rgba(255,255,255,0.15);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .player.active {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .player.current-player {
            background: rgba(255,215,0,0.2);
        }

        .player.eliminated {
            background: rgba(255,0,0,0.3);
            opacity: 0.7;
        }

        .player.eliminated::after {
            content: "ELIMINATED";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255,0,0,0.9);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.8rem;
        }

        .player-name {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .player-points {
            font-size: 1rem;
            margin-bottom: 15px;
        }

        .player-tricks {
            font-size: 0.9rem;
            opacity: 0.8;
            margin-bottom: 15px;
        }

        .player-cards {
            display: flex;
            justify-content: center;
            gap: 5px;
            flex-wrap: wrap;
            min-height: 80px;
        }

        .card {
            width: 50px;
            height: 70px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid #333;
            font-size: 0.8rem;
            position: relative;
        }

        .card:hover {
            transform: translateY(-10px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
        }

        .card.playable {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76,175,80,0.5);
        }

        .card.red {
            color: #d32f2f;
        }

        .card.black {
            color: #333;
        }

        .card-back {
            background: linear-gradient(45deg, #1565c0, #0d47a1);
            color: white;
        }

        .playing-area {
            text-align: center;
            margin: 30px 0;
        }

        .trick-area {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            min-height: 100px;
            align-items: center;
        }

        .played-card {
            width: 80px;
            height: 110px;
            background: white;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border: 2px solid #333;
            position: relative;
            font-size: 1.2rem;
            color: #333;
        }

        .played-card.red {
            color: #d32f2f;
        }

        .played-card.black {
            color: #333;
        }

        .played-card.winning {
            border-color: #ffd700;
            box-shadow: 0 0 15px rgba(255,215,0,0.8);
        }

        .played-card::after {
            content: attr(data-player);
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: white;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-primary:hover {
            background: #45a049;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #da190b;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #ff9800;
            color: white;
        }

        .btn-warning:hover {
            background: #e68900;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .game-status {
            text-align: center;
            font-size: 1.2rem;
            margin: 20px 0;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .setup-screen {
            text-align: center;
            padding: 40px;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
            margin-top: 50px;
        }

        .setup-screen h2 {
            margin-bottom: 30px;
            font-size: 2rem;
        }

        .setup-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .input-group input {
            padding: 10px;
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            text-align: center;
        }

        .stakes-indicator {
            background: #ff6b35;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            display: inline-block;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .players-section {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .controls {
                flex-wrap: wrap;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>üÉè TOEPEN V-0.6 üÉè</h1>
            <p>The Classic Dutch Card Game</p>
        </div>

        <div id="lobbyScreen" class="setup-screen" style="display: none;">
            <h2>Game Lobby</h2>
            <div class="setup-controls">
                <div class="input-group">
                    <label>Lobby Code:</label>
                    <input type="text" id="lobbyCode" placeholder="Enter lobby code or leave empty to create" style="width: 200px;">
                </div>
                <div class="input-group">
                    <label>Your Name:</label>
                    <input type="text" id="lobbyPlayerName" placeholder="Enter your name" value="Player">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-primary" onclick="createLobby()">Create Lobby</button>
                    <button class="btn btn-primary" onclick="joinLobby()">Join Lobby</button>
                    <button class="btn btn-danger" onclick="backToSetup()">Back</button>
                </div>
            </div>
            
            <div id="lobbyPlayers" style="margin-top: 30px; display: none;">
                <h3>Players in Lobby:</h3>
                <div id="playersList" style="margin: 20px 0;"></div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="addBot()" id="addBotBtn">Add Bot</button>
                    <button class="btn btn-primary" onclick="startLobbyGame()" id="startGameBtn" style="display: none;">Start Game</button>
                    <button class="btn btn-danger" onclick="leaveLobby()">Leave Lobby</button>
                </div>
                <p id="waitingMessage" style="display: none; margin-top: 15px; font-style: italic; color: #666;">Waiting for host to start the game...</p>
                <p style="margin-top: 15px; font-size: 0.9rem;">Share this code with friends: <strong id="currentLobbyCode"></strong></p>
            </div>
        </div>
        <div id="setupScreen" class="setup-screen">
            <h2>Setup Game</h2>
            <div class="setup-controls">
                <div class="input-group">
                    <label>Your Name:</label>
                    <input type="text" id="playerName" placeholder="Enter your name" value="Player">
                </div>
                <div class="input-group">
                    <label>Number of Players (2-4):</label>
                    <input type="number" id="numPlayers" min="2" max="4" value="3">
                </div>
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-primary" onclick="startGame()">Play with Bots</button>
                    <button class="btn btn-warning" onclick="showLobby()">Play with Friends</button>
                </div>
            </div>
            
            <div style="margin-top: 40px; text-align: left; max-width: 600px; margin-left: auto; margin-right: auto;">
                <h3>Hoe speel je Toepen:</h3>
                <p><strong>Doel:</strong> Zorg niet dat je de 10 punten haalt!</p>
                <p><strong>Kaarten:</strong> Piketkaarten. elke speler krijgt 4 kaarten. Je speelt 4 slagen per ronde.</p>
                <p><strong>Waardes:</strong> J (laagste), Q, K, A, 7, 8, 9, 10 (Hoogste)</p>
                <p><strong>Score:</strong> Winnaar krijgt 0 punten, losers krijgen strafpunten ter hoogte van de inzet!</p>
                <p><strong>Toepen:</strong> In jouw beurt kan je toepen om de inzet te verhogen.</p>
                <p><strong>Inzet:</strong> Start met 1, verhoogt met 1 voor elke toep. Fold is de inzet waar je voor speelde voor de toep.</p>
                <p><strong>Winnaar:</strong> Bij 10 punten verlies je. Laatste speler die overblijft wint!</p>
                <p><strong>STV:</strong> Het spel voldoet nog niet aan de stv regels, nog WIP: blind toepen, -1 met boertoep, altijd kunnen toepen</p>
            </div>
        </div>

        <div id="toepDecisionScreen" class="setup-screen" style="display: none;">
            <h2>üÉè TOEP! üÉè</h2>
            <div id="toepMessage" style="margin: 20px 0; font-size: 1.3rem;"></div>
            <div class="stakes-indicator" style="margin: 20px 0;">
                New Stakes: <span id="newStakes">2</span> points
            </div>
            <div style="margin: 20px 0; font-size: 1.1rem;">
                <p>You entered this round at <strong><span id="yourEntryStakes">1</span> points</strong></p>
                <p>If you fold now, you'll get <strong><span id="foldPenalty">1</span> penalty points</strong></p>
                <p>If you continue and lose the round, you'll get <strong><span id="continuePenalty">2</span> penalty points</strong></p>
            </div>
            <div class="setup-controls">
                <div style="display: flex; gap: 15px; justify-content: center;">
                    <button class="btn btn-primary" onclick="acceptToep()">Accept & Continue</button>
                    <button class="btn btn-danger" onclick="foldToToep()">Fold Round</button>
                </div>
            </div>
        </div>

        <div id="gameScreen" style="display: none;">
            <div class="game-info">
                <div>Round: <span id="roundNumber">1</span></div>
                <div>Current Stakes: <span id="roundValue">1</span></div>
                <div>Tricks: <span id="tricksPlayed">0</span>/4</div>
            </div>

            <div class="players-section">
                <div id="player1" class="player">
                    <div class="player-name">Player 2</div>
                    <div class="player-points">Points: 0</div>
                    <div class="player-tricks">This round: 0 tricks</div>
                    <div class="player-cards"></div>
                </div>

                <div class="playing-area">
                    <div class="trick-area" id="trickArea"></div>
                    <div class="stakes-indicator">Stakes: <span id="stakesDisplay">1</span> points</div>
                    <div class="game-status" id="gameStatus">Round starting...</div>
                </div>

                <div id="player2" class="player">
                    <div class="player-name">Player 3</div>
                    <div class="player-points">Points: 0</div>
                    <div class="player-tricks">This round: 0 tricks</div>
                    <div class="player-cards"></div>
                </div>
            </div>

            <div id="player0" class="player current-player">
                <div class="player-name">You</div>
                <div class="player-points">Points: 0</div>
                <div class="player-tricks">This round: 0 tricks</div>
                <div class="player-cards" id="yourCards"></div>
            </div>

            <div class="controls">
                <button class="btn btn-warning" id="toepBtn" onclick="toep()">Toep! (Raise Stakes)</button>
                <button class="btn btn-danger" id="foldBtn" onclick="fold()">Fold Round</button>
                <button class="btn btn-primary" id="nextRoundBtn" onclick="nextRound()" style="display: none;">Next Round</button>
                <button class="btn btn-secondary" id="vuileWasBtn" onclick="submitVuileWas()" style="display: none;">Vuile Was</button>
                <button class="btn btn-secondary" id="witteWasBtn" onclick="submitWitteWas()" style="display: none;">Witte Was</button>
                <button class="btn btn-info" id="skipLaundryBtn" onclick="skipLaundry()" style="display: none;">Skip Laundry</button>
            </div>
        </div>
    </div>

    <script>
        class ToepenGame {
            constructor() {
                this.players = [];
                this.currentPlayer = 0;
                this.round = 1;
                this.stakes = 1;
                this.deck = [];
                this.currentTrick = [];
                this.tricksPlayed = 0;
                this.gamePhase = 'setup'; // setup, laundry, playing, roundEnd, gameEnd
                this.playersInRound = [];
                this.tricksTaken = [];
                this.leadSuit = null;
                this.roundTrickWins = [];
                this.isHost = false;
                this.lobbyCode = '';
                this.lobbyPlayers = [];
                // NEW: Track the stakes each player entered the round at
                this.playerStakesOnEntry = [];
                // Laundry system
                this.laundryPhaseComplete = false;
                this.firstCardPlayed = false;
                this.pendingLaundry = null; // {playerIndex, type, cards}
                this.awaitingInspection = false;
                this.laundryPhaseTimer = null;
                // Toep restriction - track who toep'd last to prevent consecutive toeps
                this.lastToeper = -1; // -1 means no one has toep'd yet this round
            }

            createDeck() {
                const suits = ['‚ô†', '‚ô•', '‚ô¶', '‚ô£'];
                const ranks = [
                    {symbol: 'J', value: 1},    // Jack is lowest
                    {symbol: 'Q', value: 2},
                    {symbol: 'K', value: 3},
                    {symbol: 'A', value: 4},
                    {symbol: '7', value: 5},
                    {symbol: '8', value: 6},
                    {symbol: '9', value: 7},
                    {symbol: '10', value: 8}    // 10 is highest
                ];

                this.deck = [];
                suits.forEach(suit => {
                    ranks.forEach(rank => {
                        this.deck.push({
                            suit: suit,
                            rank: rank.symbol,
                            value: rank.value,
                            color: (suit === '‚ô•' || suit === '‚ô¶') ? 'red' : 'black'
                        });
                    });
                });
            }

            shuffleDeck() {
                for (let i = this.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]];
                }
            }

            dealCards() {
                this.players.forEach(player => {
                    player.hand = [];
                    for (let i = 0; i < 4; i++) {
                        player.hand.push(this.deck.pop());
                    }
                });
            }

            // Laundry detection methods
            isVuileWas(hand) {
                // Dirty laundry: 3 face cards (J, Q, K) and one 7
                const faceCards = hand.filter(card => ['J', 'Q', 'K'].includes(card.rank));
                const sevens = hand.filter(card => card.rank === '7');
                return faceCards.length === 3 && sevens.length === 1;
            }

            isWitteWas(hand) {
                // White laundry: 4 face cards (J, Q, K)
                const faceCards = hand.filter(card => ['J', 'Q', 'K'].includes(card.rank));
                return faceCards.length === 4;
            }

            hasLaundry(hand) {
                return this.isVuileWas(hand) || this.isWitteWas(hand);
            }

            getLaundryType(hand) {
                if (this.isWitteWas(hand)) return 'witte';
                if (this.isVuileWas(hand)) return 'vuile';
                return null;
            }

            startRound() {
                // Remove eliminated players
                this.players = this.players.filter(p => p.points < 10);
                
                if (this.players.length <= 1) {
                    this.endGame();
                    return;
                }

                this.createDeck();
                this.shuffleDeck();
                this.dealCards();
                
                // Reset any face-up card penalties from previous rounds
                this.players.forEach(player => {
                    player.cardsVisible = false;
                });
                this.currentTrick = [];
                this.tricksPlayed = 0;
                this.stakes = 1;
                this.playersInRound = [...Array(this.players.length).keys()];
                this.roundTrickWins = new Array(this.players.length).fill(0);
                this.gamePhase = 'laundry'; // Start with laundry phase
                this.currentPlayer = 0;
                this.leadSuit = null;
                this.laundryPhaseComplete = false;
                this.firstCardPlayed = false;
                
                // NEW: Initialize stakes tracking - all players start at stakes=1
                this.playerStakesOnEntry = new Array(this.players.length).fill(1);
                
                // Reset toep restriction for new round
                this.lastToeper = -1;
                
                this.updateDisplay();
                this.updateGameStatus(`Round ${this.round} begins! Check for laundry before playing.`);
                
                // Start laundry phase
                this.handleLaundryPhase();
            }

            handleLaundryPhase() {
                this.updateGameStatus("Laundry phase - You can claim Vuile Was (3 face cards + 1 seven) or Witte Was (4 face cards). Bluffing is allowed! Others can inspect your claim. You have 15 seconds.");
                
                // Handle AI players' laundry decisions after a delay
                setTimeout(() => this.processAILaundryDecisions(), 3000);
                
                // Set the main laundry phase timer
                this.setLaundryPhaseTimer();
            }

            setLaundryPhaseTimer() {
                // Clear existing timer if any
                if (this.laundryPhaseTimer) {
                    clearTimeout(this.laundryPhaseTimer);
                }
                
                // Set new timer - auto-end laundry phase after 15 seconds if no activity
                this.laundryPhaseTimer = setTimeout(() => {
                    if (this.gamePhase === 'laundry' && !this.awaitingInspection) {
                        this.endLaundryPhase();
                    }
                }, 15000);
            }

            processAILaundryDecisions() {
                for (let i = 1; i < this.players.length; i++) {
                    if (this.deck.length >= 4) {
                        // Check if AI has actual laundry
                        if (this.hasLaundry(this.players[i].hand)) {
                            // AI always submits laundry if they have it
                            const laundryType = this.getLaundryType(this.players[i].hand);
                            this.submitLaundry(i, laundryType);
                            return; // Process one at a time
                        } else {
                            // AI might occasionally bluff (5% chance)
                            if (Math.random() < 0.05) {
                                const bluffType = Math.random() < 0.7 ? 'vuile' : 'witte'; // More likely to claim vuile was
                                this.submitLaundry(i, bluffType);
                                return; // Process one at a time
                            }
                        }
                    }
                }
                
                // If no AI submitted laundry, continue checking or end phase
                if (!this.awaitingInspection) {
                    // Give a bit more time for human player decisions
                    setTimeout(() => {
                        if (this.gamePhase === 'laundry' && !this.awaitingInspection) {
                            this.endLaundryPhase();
                        }
                    }, 2000);
                }
            }

            submitLaundry(playerIndex, type) {
                if (this.deck.length < 4) {
                    this.updateGameStatus("Not enough cards left in deck for laundry.");
                    return false;
                }

                const player = this.players[playerIndex];
                const laundryCards = [...player.hand];
                
                this.pendingLaundry = {
                    playerIndex: playerIndex,
                    type: type,
                    cards: laundryCards
                };

                this.awaitingInspection = true;
                
                // Reset the laundry phase timer since someone made a claim
                this.setLaundryPhaseTimer();
                
                const typeText = type === 'witte' ? 'Witte was' : 'Vuile was';
                this.updateGameStatus(`${player.name} claims ${typeText}! Click on them to inspect (risky - you get penalty if they're telling the truth). Auto-proceeds in 10 seconds.`);
                
                // Auto-proceed after 10 seconds if no inspection
                setTimeout(() => {
                    if (this.awaitingInspection && this.pendingLaundry) {
                        this.processLaundry(false);
                    }
                }, 10000);

                this.updateDisplay();
                return true;
            }

            inspectLaundry(inspectorIndex) {
                if (!this.awaitingInspection || !this.pendingLaundry) return;
                
                const inspector = this.players[inspectorIndex];
                this.updateGameStatus(`${inspector.name} inspects the laundry...`);
                
                setTimeout(() => this.processLaundry(true, inspectorIndex), 1500);
            }

            processLaundry(wasInspected, inspectorIndex = -1) {
                if (!this.pendingLaundry) return;

                const { playerIndex, type, cards } = this.pendingLaundry;
                const player = this.players[playerIndex];

                if (!wasInspected) {
                    // No one inspected - player gets away with it (even if bluffing)
                    this.updateGameStatus(`No one inspects ${player.name}'s ${type === 'witte' ? 'Witte was' : 'Vuile was'} claim. ${player.name} gets new cards.`);
                    
                    // Give player new hand regardless of whether they actually had laundry
                    player.hand = [];
                    for (let i = 0; i < 4; i++) {
                        if (this.deck.length > 0) {
                            player.hand.push(this.deck.pop());
                        }
                    }
                } else {
                    // Someone inspected - now we validate the actual cards
                    const isValidLaundry = type === 'witte' ? this.isWitteWas(cards) : this.isVuileWas(cards);
                    
                    if (isValidLaundry) {
                        // Valid laundry - inspector gets penalty
                        this.players[inspectorIndex].points += 1;
                        this.updateGameStatus(`${this.players[inspectorIndex].name} inspects and finds valid ${type === 'witte' ? 'Witte was' : 'Vuile was'}! Inspector gets 1 penalty point.`);
                        
                        // Give player new hand
                        player.hand = [];
                        for (let i = 0; i < 4; i++) {
                            if (this.deck.length > 0) {
                                player.hand.push(this.deck.pop());
                            }
                        }
                    } else {
                        // Invalid laundry - bluff caught!
                        player.points += 1;
                        player.cardsVisible = true; // Play with cards face up
                        this.updateGameStatus(`${this.players[inspectorIndex].name} catches ${player.name} bluffing! ${player.name} gets 1 penalty point and must play with cards face up.`);
                    }
                }

                this.pendingLaundry = null;
                this.awaitingInspection = false;
                this.updateDisplay();

                // Continue with laundry phase or move to playing
                setTimeout(() => {
                    if (this.deck.length >= 4) {
                        this.processAILaundryDecisions();
                    } else {
                        this.endLaundryPhase();
                    }
                }, 2000);
            }

            endLaundryPhase() {
                // Clear any remaining laundry phase timer
                if (this.laundryPhaseTimer) {
                    clearTimeout(this.laundryPhaseTimer);
                    this.laundryPhaseTimer = null;
                }
                
                this.gamePhase = 'playing';
                this.laundryPhaseComplete = true;
                this.updateDisplay();
                this.updateGameStatus(`Round ${this.round} - ${this.players[this.currentPlayer].name}'s turn.`);
                
                if (this.currentPlayer !== 0) {
                    setTimeout(() => this.handleAIPlay(), 1500);
                }
            }

            toep() {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== 0) return;
                
                // Check if this player can toep (can't toep twice in a row)
                if (this.lastToeper === 0) {
                    this.updateGameStatus("You can't toep twice in a row! Wait for someone else to toep first.");
                    return;
                }
                
                this.stakes += 1;
                this.lastToeper = 0; // Mark human player as the last one to toep
                this.updateGameStatus(`You toep! Stakes raised to ${this.stakes}. Others must accept or fold.`);
                
                // DON'T update stakes tracking yet - only update for players who accept
                
                // Check if other players accept or fold
                setTimeout(() => this.handleToepResponse(), 1000);
                this.updateDisplay();
            }

            handleToepResponse() {
                let playersToRespond = this.playersInRound.filter(p => p !== 0);
                let playersFolded = [];
                let playersAccepted = [];
                
                playersToRespond.forEach(playerIndex => {
                    // AI decision: 40% chance to fold when stakes are high
                    const foldChance = this.stakes >= 4 ? 0.4 : 0.2;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    } else {
                        playersAccepted.push(playerIndex);
                        // Update stakes tracking for AI players who accept
                        this.playerStakesOnEntry[playerIndex] = this.stakes;
                    }
                });
                
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = this.playerStakesOnEntry[p];
                        this.players[p].points += penaltyPoints;
                        foldMessages.push(`${this.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    this.updateGameStatus(`${foldMessages.join(', ')} fold(s)!`);
                    this.playersInRound = this.playersInRound.filter(p => !playersFolded.includes(p));
                }
                
                if (this.playersInRound.length === 1) {
                    this.updateGameStatus("You're the only player left! Round over.");
                    setTimeout(() => this.endRound(), 2000);
                    return;
                }
                
                let acceptedNames = this.playersInRound.filter(p => p !== 0).map(p => this.players[p].name).join(', ');
                if (acceptedNames) {
                    this.updateGameStatus(`${acceptedNames} accept(s) the toep! Continue playing.`);
                }
                
                setTimeout(() => {
                    if (this.currentPlayer !== 0) {
                        this.handleAIPlay();
                    }
                }, 1500);
                
                this.updateDisplay();
            }

            fold() {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== 0) return;
                
                // Player gets penalty points based on when they entered the round
                const penaltyPoints = this.playerStakesOnEntry[0];
                this.players[0].points += penaltyPoints;
                this.playersInRound = this.playersInRound.filter(p => p !== 0);
                
                this.updateGameStatus(`You fold and get ${penaltyPoints} penalty points!`);
                
                if (this.playersInRound.length === 1) {
                    this.updateGameStatus(`${this.players[this.playersInRound[0]].name} wins the round!`);
                    setTimeout(() => this.endRound(), 2000);
                    return;
                }
                
                // Continue with remaining AI players
                this.currentPlayer = this.playersInRound[0];
                setTimeout(() => {
                    if (this.currentPlayer !== 0) {
                        this.handleAIPlay();
                    }
                }, 1500);
                
                this.updateDisplay();
            }

            playCard(cardIndex) {
                if (this.gamePhase !== 'playing' || this.currentPlayer !== 0) return;
                if (!this.playersInRound.includes(0)) return;
                
                const card = this.players[0].hand[cardIndex];
                if (!this.isValidPlay(card)) {
                    this.updateGameStatus("Invalid play! You must follow suit if possible.");
                    return;
                }
                
                // Mark that first card has been played - no more laundry allowed
                if (!this.firstCardPlayed) {
                    this.firstCardPlayed = true;
                }
                
                this.players[0].hand.splice(cardIndex, 1);
                this.currentTrick.push({card: card, player: 0});
                
                if (this.currentTrick.length === 1) {
                    this.leadSuit = card.suit;
                }
                
                this.nextPlayer();
                this.updateDisplay();
                
                if (this.currentTrick.length < this.playersInRound.length) {
                    setTimeout(() => this.handleAIPlay(), 1500);
                } else {
                    setTimeout(() => this.evaluateTrick(), 2000);
                }
            }

            nextPlayer() {
                do {
                    this.currentPlayer = (this.currentPlayer + 1) % this.players.length;
                } while (!this.playersInRound.includes(this.currentPlayer));
            }

            handleAIPlay() {
                if (this.currentPlayer === 0 || !this.playersInRound.includes(this.currentPlayer)) return;
                
                // AI might toep occasionally on their turn (but only if they can)
                if (Math.random() < 0.12 && this.stakes < 8 && this.lastToeper !== this.currentPlayer) {
                    setTimeout(() => this.handleAIToep(), 500);
                    return;
                }
                
                const player = this.players[this.currentPlayer];
                const validCards = player.hand.filter(card => this.isValidPlay(card));
                
                // Simple AI: try to avoid winning tricks
                let cardToPlay = validCards[0];
                if (this.currentTrick.length > 0) {
                    // Try to play lowest valid card to avoid winning
                    cardToPlay = validCards.reduce((lowest, card) => 
                        card.value < lowest.value ? card : lowest
                    );
                }
                
                // Mark that first card has been played - no more laundry allowed
                if (!this.firstCardPlayed) {
                    this.firstCardPlayed = true;
                }
                
                const cardIndex = player.hand.indexOf(cardToPlay);
                player.hand.splice(cardIndex, 1);
                this.currentTrick.push({card: cardToPlay, player: this.currentPlayer});
                
                if (this.currentTrick.length === 1) {
                    this.leadSuit = cardToPlay.suit;
                }
                
                this.nextPlayer();
                this.updateDisplay();
                
                if (this.currentTrick.length < this.playersInRound.length) {
                    if (this.currentPlayer !== 0) {
                        setTimeout(() => this.handleAIPlay(), 1500);
                    }
                } else {
                    setTimeout(() => this.evaluateTrick(), 2000);
                }
            }

            handleAIToep() {
                this.stakes += 1;
                this.lastToeper = this.currentPlayer; // Mark this AI player as the last one to toep
                this.updateGameStatus(`${this.players[this.currentPlayer].name} toeps! Stakes now ${this.stakes}.`);
                
                // DON'T update stakes tracking yet - only update for players who accept
                
                // Other players (including human) might fold
                setTimeout(() => this.handleToepResponseFromAI(), 1000);
                this.updateDisplay();
            }

            handleToepResponseFromAI() {
                let playersToRespond = this.playersInRound.filter(p => p !== this.currentPlayer);
                let playersFolded = [];
                
                // Check if human player needs to decide
                if (playersToRespond.includes(0)) {
                    this.showToepDecisionScreen();
                    return; // Wait for human decision
                }
                
                // Handle AI-only responses
                let playersAccepted = [];
                playersToRespond.forEach(playerIndex => {
                    const foldChance = this.stakes >= 4 ? 0.4 : 0.25;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    } else {
                        playersAccepted.push(playerIndex);
                        // Update stakes tracking for AI players who accept
                        this.playerStakesOnEntry[playerIndex] = this.stakes;
                    }
                });
                
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = this.playerStakesOnEntry[p];
                        this.players[p].points += penaltyPoints;
                        foldMessages.push(`${this.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    this.updateGameStatus(`${foldMessages.join(', ')} fold(s)!`);
                    this.playersInRound = this.playersInRound.filter(p => !playersFolded.includes(p));
                }
                
                if (this.playersInRound.length === 1) {
                    setTimeout(() => this.endRound(), 2000);
                    return;
                }
                
                // Continue playing
                setTimeout(() => this.handleAIPlay(), 1000);
                this.updateDisplay();
            }

            isValidPlay(card) {
                if (this.currentTrick.length === 0) return true;
                
                const player = this.players[this.currentPlayer];
                const hasSuit = player.hand.some(c => c.suit === this.leadSuit);
                
                return !hasSuit || card.suit === this.leadSuit;
            }

            evaluateTrick() {
                let winner = this.currentTrick[0];
                
                // Find highest card of lead suit
                this.currentTrick.forEach(play => {
                    if (play.card.suit === this.leadSuit && play.card.value > winner.card.value) {
                        winner = play;
                    }
                });
                
                this.roundTrickWins[winner.player]++;
                
                this.updateGameStatus(`${this.players[winner.player].name} wins the trick!`);
                
                this.tricksPlayed++;
                this.currentTrick = [];
                this.leadSuit = null;
                
                if (this.tricksPlayed === 4) {
                    setTimeout(() => this.endRound(), 2000);
                } else {
                    this.currentPlayer = winner.player;
                    setTimeout(() => {
                        this.updateGameStatus(`${this.players[this.currentPlayer].name}'s turn to lead.`);
                        if (this.currentPlayer !== 0) {
                            setTimeout(() => this.handleAIPlay(), 1000);
                        }
                    }, 2000);
                }
                
                this.updateDisplay();
            }

            endRound() {
                // Find the player who won the most tricks (winner gets 0 points, others get penalty)
                let maxTricks = Math.max(...this.playersInRound.map(p => this.roundTrickWins[p]));
                let winners = this.playersInRound.filter(p => this.roundTrickWins[p] === maxTricks);
                
                // If there's a tie for most tricks, all tied players get 0 points
                let winnerNames = winners.map(w => this.players[w].name).join(', ');
                
                // All non-winners get penalty points equal to their entry stakes
                this.playersInRound.forEach(playerIndex => {
                    if (!winners.includes(playerIndex)) {
                        const penaltyPoints = this.playerStakesOnEntry[playerIndex];
                        this.players[playerIndex].points += penaltyPoints;
                    }
                });
                
                let roundSummary = `${winnerNames} won with ${maxTricks} tricks (0 points). Others get penalty points.`;
                this.updateGameStatus(`Round ${this.round} complete! ${roundSummary}`);
                
                // Check for eliminated players
                const eliminated = this.players.filter(p => p.points >= 10);
                if (eliminated.length > 0) {
                    let eliminatedNames = eliminated.map(p => p.name).join(', ');
                    setTimeout(() => {
                        this.updateGameStatus(`${eliminatedNames} eliminated! (10+ points)`);
                    }, 2000);
                    
                    if (this.players.filter(p => p.points < 10).length <= 1) {
                        setTimeout(() => this.endGame(), 4000);
                        return;
                    }
                }
                
                this.round++;
                this.gamePhase = 'roundEnd';
                setTimeout(() => this.updateDisplay(), 2000);
            }

            endGame() {
                const survivors = this.players.filter(p => p.points < 10);
                if (survivors.length === 1) {
                    this.updateGameStatus(`üéâ ${survivors[0].name} wins the game! üéâ`);
                } else if (survivors.length > 1) {
                    let winnerNames = survivors.map(p => p.name).join(', ');
                    this.updateGameStatus(`üéâ ${winnerNames} survive and win! üéâ`);
                } else {
                    this.updateGameStatus(`üéâ Game over! üéâ`);
                }
                this.gamePhase = 'gameEnd';
                this.updateDisplay();
            }

            nextRound() {
                this.startRound();
            }

            updateDisplay() {
                // Update round info
                document.getElementById('roundNumber').textContent = this.round;
                document.getElementById('roundValue').textContent = this.stakes;
                document.getElementById('stakesDisplay').textContent = this.stakes;
                document.getElementById('tricksPlayed').textContent = this.tricksPlayed;
                
                // Update player displays
                this.players.forEach((player, index) => {
                    const playerEl = document.getElementById(`player${index}`);
                    if (playerEl) {
                        playerEl.querySelector('.player-name').textContent = player.name;
                        playerEl.querySelector('.player-points').textContent = `Points: ${player.points}`;
                        
                        const tricksEl = playerEl.querySelector('.player-tricks');
                        if (tricksEl) {
                            tricksEl.textContent = `This round: ${this.roundTrickWins[index] || 0} tricks`;
                        }
                        
                        const cardsEl = playerEl.querySelector('.player-cards');
                        cardsEl.innerHTML = '';
                        
                        if (index === 0) {
                            // Show human player's cards
                            player.hand.forEach((card, cardIndex) => {
                                const cardEl = document.createElement('div');
                                cardEl.className = `card ${card.color}`;
                                cardEl.textContent = `${card.rank}${card.suit}`;
                                
                                // Only add click handler and make playable if it's the player's turn
                                if (this.gamePhase === 'playing' && this.currentPlayer === 0 && 
                                    this.playersInRound.includes(0) && this.isValidPlay(card)) {
                                    cardEl.classList.add('playable');
                                    cardEl.onclick = () => {
                                        if (isMultiplayer) {
                                            socket.emit('gameAction', { type: 'playCard', cardIndex: cardIndex });
                                        } else {
                                            this.playCard(cardIndex);
                                        }
                                    };
                                    cardEl.style.cursor = 'pointer';
                                } else {
                                    cardEl.style.cursor = 'not-allowed';
                                    cardEl.style.opacity = this.currentPlayer === 0 ? '0.6' : '0.3';
                                }
                                
                                cardsEl.appendChild(cardEl);
                            });
                        } else if (this.playersInRound.includes(index)) {
                            // Show cards for AI players still in the round
                            if (player.cardsVisible) {
                                // Show face-up cards for players with invalid laundry penalty
                                player.hand.forEach(card => {
                                    const cardEl = document.createElement('div');
                                    cardEl.className = `card ${card.color}`;
                                    cardEl.textContent = `${card.rank}${card.suit}`;
                                    cardEl.style.border = '2px solid #ff6b6b'; // Red border for penalty
                                    cardsEl.appendChild(cardEl);
                                });
                            } else {
                                // Show card backs for normal AI players
                                for (let i = 0; i < player.hand.length; i++) {
                                    const cardEl = document.createElement('div');
                                    cardEl.className = 'card card-back';
                                    cardEl.textContent = 'üÇ†';
                                    cardsEl.appendChild(cardEl);
                                }
                            }
                        } else {
                            // Show empty space for folded players
                            const foldedEl = document.createElement('div');
                            foldedEl.textContent = 'FOLDED';
                            foldedEl.style.color = '#ff6b6b';
                            foldedEl.style.fontWeight = 'bold';
                            cardsEl.appendChild(foldedEl);
                        }
                        
                        // Highlight active player
                        playerEl.classList.toggle('active', this.currentPlayer === index && this.gamePhase === 'playing');
                        
                        // Show eliminated players
                        playerEl.classList.toggle('eliminated', player.points >= 10);
                        
                        // Laundry inspection - make players clickable if awaiting inspection
                        if (this.awaitingInspection && this.pendingLaundry && 
                            this.pendingLaundry.playerIndex === index) {
                            playerEl.style.cursor = 'pointer';
                            playerEl.style.border = '3px solid #ffeb3b';
                            playerEl.title = 'Click to inspect laundry';
                            playerEl.onclick = () => {
                                if (isMultiplayer) {
                                    socket.emit('gameAction', { type: 'inspectLaundry' });
                                } else {
                                    this.inspectLaundry(0);
                                }
                            };
                        } else if (this.awaitingInspection && index !== 0 && 
                                   this.pendingLaundry && this.pendingLaundry.playerIndex !== index) {
                            // Other AI players can inspect too (simulate) - reduced chance
                            if (Math.random() < 0.03) { // 3% chance AI inspects (rare but possible)
                                setTimeout(() => this.inspectLaundry(index), Math.random() * 5000 + 2000);
                            }
                        } else {
                            playerEl.style.cursor = 'default';
                            playerEl.style.border = 'none';
                            playerEl.title = '';
                            playerEl.onclick = null;
                        }
                        
                        // Show if player folded this round
                        if (!this.playersInRound.includes(index) && this.gamePhase === 'playing') {
                            playerEl.style.opacity = '0.6';
                        } else {
                            playerEl.style.opacity = '1';
                        }
                    }
                });
                
                // Update trick area
                const trickArea = document.getElementById('trickArea');
                trickArea.innerHTML = '';
                this.currentTrick.forEach(play => {
                    const cardEl = document.createElement('div');
                    cardEl.className = `played-card ${play.card.color}`;
                    
                    // Create card content with proper structure
                    const cardContent = document.createElement('div');
                    cardContent.textContent = `${play.card.rank}${play.card.suit}`;
                    cardContent.style.fontSize = '1.2rem';
                    cardContent.style.fontWeight = 'bold';
                    
                    cardEl.appendChild(cardContent);
                    cardEl.setAttribute('data-player', this.players[play.player].name);
                    
                    // Highlight the winning card if trick is complete
                    if (this.currentTrick.length === this.playersInRound.length) {
                        let winner = this.currentTrick[0];
                        this.currentTrick.forEach(p => {
                            if (p.card.suit === this.leadSuit && p.card.value > winner.card.value) {
                                winner = p;
                            }
                        });
                        if (play === winner) {
                            cardEl.classList.add('winning');
                        }
                    }
                    
                    trickArea.appendChild(cardEl);
                });
                
                // Update controls
                const toepBtn = document.getElementById('toepBtn');
                const foldBtn = document.getElementById('foldBtn');
                const nextRoundBtn = document.getElementById('nextRoundBtn');
                const vuileWasBtn = document.getElementById('vuileWasBtn');
                const witteWasBtn = document.getElementById('witteWasBtn');
                const skipLaundryBtn = document.getElementById('skipLaundryBtn');
                
                const canToep = this.gamePhase === 'playing' && this.currentPlayer === 0 && 
                              this.playersInRound.includes(0) && this.stakes < 16 && this.lastToeper !== 0;
                const canFold = this.gamePhase === 'playing' && this.playersInRound.includes(0);
                
                // Laundry buttons visibility - always show both during laundry phase (allow bluffing)
                const inLaundryPhase = this.gamePhase === 'laundry' && !this.awaitingInspection;
                const canSubmitVuileWas = inLaundryPhase;
                const canSubmitWitteWas = inLaundryPhase;
                const canSkipLaundry = inLaundryPhase;
                
                toepBtn.style.display = canToep ? 'inline-block' : 'none';
                foldBtn.style.display = canFold ? 'inline-block' : 'none';
                nextRoundBtn.style.display = (this.gamePhase === 'roundEnd') ? 'inline-block' : 'none';
                vuileWasBtn.style.display = canSubmitVuileWas ? 'inline-block' : 'none';
                witteWasBtn.style.display = canSubmitWitteWas ? 'inline-block' : 'none';
                skipLaundryBtn.style.display = canSkipLaundry ? 'inline-block' : 'none';
                
                toepBtn.disabled = !canToep;
                foldBtn.disabled = !canFold;
            }

            updateGameStatus(message) {
                document.getElementById('gameStatus').textContent = message;
            }

            showToepDecisionScreen() {
                const toepper = this.players[this.currentPlayer].name;
                const yourEntryStakes = this.playerStakesOnEntry[0];
                
                document.getElementById('toepMessage').textContent = `${toepper} toeps! Stakes raised to ${this.stakes} points.`;
                document.getElementById('newStakes').textContent = this.stakes;
                document.getElementById('yourEntryStakes').textContent = yourEntryStakes;
                document.getElementById('foldPenalty').textContent = yourEntryStakes;
                document.getElementById('continuePenalty').textContent = this.stakes;
                
                document.getElementById('gameScreen').style.display = 'none';
                document.getElementById('toepDecisionScreen').style.display = 'block';
            }

            hideToepDecisionScreen() {
                document.getElementById('toepDecisionScreen').style.display = 'none';
                document.getElementById('gameScreen').style.display = 'block';
            }
        }

        let game = new ToepenGame();
        let currentLobby = null;
        
        // Initialize Socket.io connection
        const socket = io();
        let isMultiplayer = false;
        let myPlayerIndex = -1;
        
        // Socket event handlers
        socket.on('roomCreated', (data) => {
            currentLobby = {
                code: data.roomCode,
                players: data.players,
                isHost: true
            };
            
            document.getElementById('currentLobbyCode').textContent = data.roomCode;
            document.getElementById('lobbyPlayers').style.display = 'block';
            document.getElementById('startGameBtn').style.display = 'inline-block';
            updateLobbyDisplay();
        });
        
        socket.on('roomJoined', (data) => {
            currentLobby = {
                code: data.roomCode,
                players: data.players,
                isHost: data.isHost
            };
            
            document.getElementById('currentLobbyCode').textContent = data.roomCode;
            document.getElementById('lobbyPlayers').style.display = 'block';
            document.getElementById('startGameBtn').style.display = data.isHost ? 'inline-block' : 'none';
            updateLobbyDisplay();
            showMessage(`Joined lobby ${data.roomCode}!`);
        });
        
        socket.on('playerJoined', (data) => {
            if (currentLobby) {
                currentLobby.players = data.players;
                updateLobbyDisplay();
                showMessage(`${data.joinedPlayer} joined the lobby!`);
            }
        });
        
        socket.on('gameStarted', (data) => {
            isMultiplayer = true;
            myPlayerIndex = data.gameState.players.findIndex(p => p.id === socket.id);
            
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            // Sync with the server's initial game state (cards already dealt)
            syncGameState(data.gameState);
        });
        
        socket.on('gameStateUpdate', (data) => {
            if (isMultiplayer) {
                syncGameState(data.gameState);
                
                // Handle game event messages
                if (data.lastAction) {
                    handleGameEvent(data.lastAction, data.gameState);
                }
            }
        });
        
        socket.on('joinError', (error) => {
            alert(`Failed to join lobby: ${error}`);
        });
        
        socket.on('error', (error) => {
            alert(`Error: ${error}`);
        });
        
        function showMessage(text) {
            // Simple message display - you can enhance this
            const status = document.getElementById('gameStatus');
            if (status) {
                status.textContent = text;
            }
        }
        
        function handleGameEvent(action, gameState) {
            switch (action.type) {
                case 'playCard':
                    const playerName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${playerName} played a card.`);
                    break;
                case 'trickComplete':
                    if (gameState.lastTrickWinner) {
                        game.updateGameStatus(`${gameState.lastTrickWinner} wins the trick!`);
                    }
                    break;
                case 'toep':
                    const toepperName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${toepperName} toeps! Stakes raised to ${gameState.stakes}.`);
                    break;
                case 'acceptToep':
                    const accepterName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${accepterName} accepts the toep.`);
                    break;
                case 'foldToToep':
                    const folderName = gameState.players[action.playerIndex]?.name || 'Unknown';
                    game.updateGameStatus(`${folderName} folds to the toep.`);
                    break;
                case 'submitLaundry':
                    const laundryPlayer = gameState.players[action.playerIndex]?.name || 'Unknown';
                    const laundryType = action.laundryType === 'witte' ? 'Witte was' : 'Vuile was';
                    game.updateGameStatus(`${laundryPlayer} claims ${laundryType}! Click to inspect or wait.`);
                    break;
                case 'laundryPhaseEnd':
                    game.updateGameStatus(`Laundry phase ended. Game begins!`);
                    break;
                case 'newRound':
                    game.updateGameStatus(`Round ${gameState.round} begins! Check for laundry.`);
                    break;
                case 'toepResponsesComplete':
                    game.updateGameStatus(`All players responded to toep. Continuing game.`);
                    break;
            }
        }
        
        function syncGameState(serverState) {
            // Find this player's index in the server state
            const myServerIndex = serverState.players.findIndex(p => p.id === socket.id);
            if (myServerIndex === -1) return;
            
            // Reorder players so this player is always index 0 (bottom of screen)
            const reorderedPlayers = [];
            for (let i = 0; i < serverState.players.length; i++) {
                const serverIndex = (myServerIndex + i) % serverState.players.length;
                const serverPlayer = serverState.players[serverIndex];
                reorderedPlayers.push({
                    name: serverPlayer.name,
                    points: serverPlayer.points,
                    hand: serverPlayer.hand,
                    isBot: false,
                    cardsVisible: serverPlayer.cardsVisible || false
                });
            }
            
            game.players = reorderedPlayers;
            
            // Convert server current player index to local perspective
            game.currentPlayer = (serverState.currentPlayer - myServerIndex + serverState.players.length) % serverState.players.length;
            
            // Convert other indices that reference players
            game.lastToeper = serverState.lastToeper === -1 ? -1 : 
                (serverState.lastToeper - myServerIndex + serverState.players.length) % serverState.players.length;
            
            // Handle playersInRound array
            game.playersInRound = serverState.playersInRound.map(serverIndex => 
                (serverIndex - myServerIndex + serverState.players.length) % serverState.players.length
            );
            
            // Handle roundTrickWins array
            game.roundTrickWins = [];
            for (let i = 0; i < serverState.players.length; i++) {
                const serverIndex = (myServerIndex + i) % serverState.players.length;
                game.roundTrickWins[i] = serverState.roundTrickWins[serverIndex] || 0;
            }
            
            // Handle playerStakesOnEntry array
            game.playerStakesOnEntry = [];
            for (let i = 0; i < serverState.players.length; i++) {
                const serverIndex = (myServerIndex + i) % serverState.players.length;
                game.playerStakesOnEntry[i] = serverState.playerStakesOnEntry[serverIndex] || 1;
            }
            
            // Convert current trick player indices
            game.currentTrick = serverState.currentTrick.map(play => ({
                card: play.card,
                player: (play.player - myServerIndex + serverState.players.length) % serverState.players.length
            }));
            
            // Simple properties that don't need conversion
            game.round = serverState.round;
            game.stakes = serverState.stakes;
            game.gamePhase = serverState.gamePhase;
            game.awaitingInspection = serverState.awaitingInspection;
            game.tricksPlayed = serverState.tricksPlayed;
            game.leadSuit = serverState.leadSuit;
            
            // Handle toep responses (if exists)
            if (serverState.toepResponses) {
                game.toepResponses = [];
                for (let i = 0; i < serverState.players.length; i++) {
                    const serverIndex = (myServerIndex + i) % serverState.players.length;
                    game.toepResponses[i] = serverState.toepResponses[serverIndex];
                }
            } else {
                game.toepResponses = null;
            }
            
            // Handle pending laundry
            if (serverState.pendingLaundry) {
                game.pendingLaundry = {
                    ...serverState.pendingLaundry,
                    playerIndex: (serverState.pendingLaundry.playerIndex - myServerIndex + serverState.players.length) % serverState.players.length
                };
            } else {
                game.pendingLaundry = null;
            }
            
            // Show/hide toep decision screen based on game state
            if (serverState.gamePhase === 'toepResponse' && 
                serverState.toepResponses && 
                serverState.toepResponses[myServerIndex] === null &&
                serverState.playersInRound.includes(myServerIndex)) {
                game.showToepDecisionScreen();
            } else {
                // Hide toep decision screen if it's showing and no longer needed
                if (document.getElementById('toepDecisionScreen').style.display !== 'none') {
                    game.hideToepDecisionScreen();
                }
            }
            
            game.updateDisplay();
        }

        function showLobby() {
            // Sync name from setup screen to lobby screen
            const setupName = document.getElementById('playerName').value || 'Player';
            document.getElementById('lobbyPlayerName').value = setupName;
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('lobbyScreen').style.display = 'block';
        }

        function backToSetup() {
            // Sync name back from lobby screen to setup screen
            const lobbyName = document.getElementById('lobbyPlayerName').value || 'Player';
            document.getElementById('playerName').value = lobbyName;
            
            document.getElementById('lobbyScreen').style.display = 'none';
            document.getElementById('setupScreen').style.display = 'block';
        }

        function createLobby() {
            const playerName = document.getElementById('lobbyPlayerName').value || 'Player';
            
            if (!playerName.trim()) {
                alert('Please enter your name!');
                return;
            }
            
            // Send create room request to server
            socket.emit('createRoom', playerName);
        }

        function joinLobby() {
            const playerName = document.getElementById('lobbyPlayerName').value || 'Player';
            const lobbyCode = document.getElementById('lobbyCode').value.toUpperCase();
            
            if (!lobbyCode) {
                alert('Please enter a lobby code!');
                return;
            }
            
            if (!playerName.trim()) {
                alert('Please enter your name!');
                return;
            }
            
            // Send join room request to server
            socket.emit('joinRoom', { roomCode: lobbyCode, playerName: playerName });
        }

        function addBot() {
            if (!currentLobby || currentLobby.players.length >= currentLobby.maxPlayers) return;
            
            const botNumber = currentLobby.players.filter(p => p.isBot).length + 1;
            currentLobby.players.push({
                name: `Bot ${botNumber}`,
                isBot: true,
                isHost: false
            });
            
            updateLobbyDisplay();
        }

        function leaveLobby() {
            currentLobby = null;
            game.lobbyCode = '';
            game.isHost = false;
            
            document.getElementById('lobbyPlayers').style.display = 'none';
            document.getElementById('lobbyCode').value = '';
            backToSetup();
        }

        function startLobbyGame() {
            if (!currentLobby || !currentLobby.isHost) return;
            
            if (currentLobby.players.length < 2) {
                alert('Need at least 2 players to start the game!');
                return;
            }
            
            // Send start game request to server
            socket.emit('startGame');
        }

        function updateLobbyDisplay() {
            if (!currentLobby) return;
            
            const playersList = document.getElementById('playersList');
            playersList.innerHTML = '';
            
            currentLobby.players.forEach((player, index) => {
                const playerDiv = document.createElement('div');
                playerDiv.style.cssText = 'padding: 10px; margin: 5px; background: rgba(255,255,255,0.1); border-radius: 5px; display: flex; justify-content: space-between; align-items: center;';
                
                const playerInfo = document.createElement('span');
                playerInfo.textContent = `${player.name} ${player.isHost ? '(Host)' : ''} ${player.isBot ? '(Bot)' : ''}`;
                
                playerDiv.appendChild(playerInfo);
                
                if (player.isBot && currentLobby.isHost) {
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = 'Remove';
                    removeBtn.className = 'btn btn-danger';
                    removeBtn.style.cssText = 'padding: 5px 10px; font-size: 0.8rem;';
                    removeBtn.onclick = () => removeBot(index);
                    playerDiv.appendChild(removeBtn);
                }
                
                playersList.appendChild(playerDiv);
            });
            
            const addBotBtn = document.getElementById('addBotBtn');
            addBotBtn.style.display = (currentLobby.players.length < currentLobby.maxPlayers && currentLobby.isHost) ? 'inline-block' : 'none';
            
            const startBtn = document.getElementById('startGameBtn');
            startBtn.style.display = (currentLobby.players.length >= 2 && currentLobby.isHost) ? 'inline-block' : 'none';
            
            const waitingMsg = document.getElementById('waitingMessage');
            waitingMsg.style.display = (currentLobby.players.length >= 2 && !currentLobby.isHost) ? 'block' : 'none';
        }

        function removeBot(index) {
            if (!currentLobby || !currentLobby.players[index].isBot || !currentLobby.isHost) return;
            
            currentLobby.players.splice(index, 1);
            updateLobbyDisplay();
        }

        function generateLobbyCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function startGame() {
            const playerName = document.getElementById('playerName').value || 'Player';
            const numPlayers = parseInt(document.getElementById('numPlayers').value);
            
            game.players = [{name: playerName, points: 0, hand: []}];
            
            for (let i = 1; i < numPlayers; i++) {
                game.players.push({name: `Player ${i + 1}`, points: 0, hand: []});
            }
            
            document.getElementById('setupScreen').style.display = 'none';
            document.getElementById('gameScreen').style.display = 'block';
            
            game.startRound();
        }

        function toep() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'toep' });
            } else {
                game.toep();
            }
        }

        function fold() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'fold' });
            } else {
                game.fold();
            }
        }

        function nextRound() {
            game.nextRound();
        }

        function acceptToep() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'acceptToep' });
                game.hideToepDecisionScreen();
            } else {
                game.hideToepDecisionScreen();
                
                // Update stakes tracking for human player who accepts
                game.playerStakesOnEntry[0] = game.stakes;
                
                // Continue with AI responses for other players
                let playersToRespond = game.playersInRound.filter(p => p !== game.currentPlayer && p !== 0);
                let playersFolded = [];
                let playersAccepted = [];
                
                playersToRespond.forEach(playerIndex => {
                    const foldChance = game.stakes >= 4 ? 0.4 : 0.25;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    } else {
                        playersAccepted.push(playerIndex);
                        // Update stakes tracking for AI players who accept
                        game.playerStakesOnEntry[playerIndex] = game.stakes;
                    }
                });
                
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = game.playerStakesOnEntry[p];
                        game.players[p].points += penaltyPoints;
                        foldMessages.push(`${game.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    game.updateGameStatus(`You accept! ${foldMessages.join(', ')} fold(s)!`);
                    game.playersInRound = game.playersInRound.filter(p => !playersFolded.includes(p));
                } else {
                    game.updateGameStatus(`You accept the toep! All players continue.`);
                }
                
                if (game.playersInRound.length === 1) {
                    setTimeout(() => game.endRound(), 2000);
                    return;
                }
                
                // Continue playing
                setTimeout(() => {
                    if (game.currentPlayer !== 0) {
                        game.handleAIPlay();
                    }
                }, 1500);
                
                game.updateDisplay();
            }
        }

        function foldToToep() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'foldToToep' });
                game.hideToepDecisionScreen();
            } else {
                game.hideToepDecisionScreen();
                
                // Player folds - gets penalty points based on entry stakes
                const penaltyPoints = game.playerStakesOnEntry[0];
                game.players[0].points += penaltyPoints;
                game.playersInRound = game.playersInRound.filter(p => p !== 0);
                
                game.updateGameStatus(`You fold and get ${penaltyPoints} penalty points!`);
                
                // Continue with other AI responses
                let playersToRespond = game.playersInRound.filter(p => p !== game.currentPlayer);
                let playersFolded = [];
                let playersAccepted = [];
                
                playersToRespond.forEach(playerIndex => {
                    const foldChance = game.stakes >= 4 ? 0.4 : 0.25;
                    if (Math.random() < foldChance) {
                        playersFolded.push(playerIndex);
                    } else {
                        playersAccepted.push(playerIndex);
                        // Update stakes tracking for AI players who accept
                        game.playerStakesOnEntry[playerIndex] = game.stakes;
                    }
                });
                
                if (playersFolded.length > 0) {
                    let foldMessages = [];
                    playersFolded.forEach(p => {
                        const penaltyPoints = game.playerStakesOnEntry[p];
                        game.players[p].points += penaltyPoints;
                        foldMessages.push(`${game.players[p].name} (gets ${penaltyPoints} pts)`);
                    });
                    
                    setTimeout(() => {
                        game.updateGameStatus(`${foldMessages.join(', ')} also fold(s)!`);
                        game.playersInRound = game.playersInRound.filter(p => !playersFolded.includes(p));
                        
                        if (game.playersInRound.length === 1) {
                            game.updateGameStatus(`${game.players[game.playersInRound[0]].name} wins the round!`);
                            setTimeout(() => game.endRound(), 2000);
                            return;
                        }
                        
                        // Continue with remaining players
                        game.currentPlayer = game.playersInRound[0];
                        setTimeout(() => game.handleAIPlay(), 1000);
                        game.updateDisplay();
                    }, 1000);
                } else {
                    if (game.playersInRound.length === 1) {
                        game.updateGameStatus(`${game.players[game.playersInRound[0]].name} wins the round!`);
                        setTimeout(() => game.endRound(), 2000);
                        return;
                    }
                    
                    // Continue with remaining players
                    setTimeout(() => {
                        if (game.currentPlayer !== 0) {
                            game.handleAIPlay();
                        }
                    }, 1500);
                }
                
                game.updateDisplay();
            }
        }

        function submitVuileWas() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'submitLaundry', laundryType: 'vuile' });
            } else {
                if (game.gamePhase !== 'laundry' || game.awaitingInspection) return;
                game.submitLaundry(0, 'vuile');
            }
        }

        function submitWitteWas() {
            if (isMultiplayer) {
                socket.emit('gameAction', { type: 'submitLaundry', laundryType: 'witte' });
            } else {
                if (game.gamePhase !== 'laundry' || game.awaitingInspection) return;
                game.submitLaundry(0, 'witte');
            }
        }

        function skipLaundry() {
            if (game.gamePhase !== 'laundry' || game.awaitingInspection) return;
            game.endLaundryPhase();
        }
    </script>
</body>
</html>